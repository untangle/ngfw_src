/**
 * $Id$
 */

package com.untangle.uvm;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.activation.MimetypesFileTypeMap;
import javax.mail.Address;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.Part;
import javax.mail.Session;
import javax.mail.event.TransportEvent;
import javax.mail.event.TransportListener;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.InternetHeaders;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

import com.sun.mail.smtp.SMTPTransport;
import com.untangle.uvm.MailSender;
import com.untangle.uvm.MailSettings;
import com.untangle.uvm.SettingsManager;
import com.untangle.uvm.UvmContext;
import com.untangle.uvm.UvmContextFactory;
import com.untangle.uvm.MailSettings.SendMethod;
import com.untangle.uvm.network.NetworkSettings;
import com.untangle.uvm.util.I18nUtil;

/**
 * Note that this class is designed to be used <b>BOTH</b> inside the UVM and as
 * a stand-alone application. The stand-alone mode is used for mailing out
 * Untangle Reports.
 */
public class MailSenderImpl implements MailSender
{
    public static final String Mailer = "UVM MailSender";

    /**
     * When using the cloud based mail relay server, we will connect to xinetd
     * on localhost, which will launch stunnel to connect to the cloud server
     * which will then pass the traffic to the relay server. This is the port
     * where the localhost inetd is listening for these connections.
     */
    public static int STUNNEL_RELAY_PORT = 2525;

    // JavaMail constants
    private static final String MAIL_HOST_PROP = "mail.host";
    private static final String MAIL_SMTP_LOCALHOST_PROP = "mail.smtp.localhost";
    private static final String MAIL_ENVELOPE_FROM_PROP = "mail.smtp.from";
    private static final String MAIL_FROM_PROP = "mail.from";
    private static final String MAIL_TRANSPORT_PROTO_PROP = "mail.transport.protocol";

    private static final String EXIM_CMD_RESTART_EXIM = System.getProperty("uvm.bin.dir") + "/ut-restart-exim.sh";
    private static final String EXIM_CONF_DIR = "/etc/exim4";
    private static final String EXIM_CONF_FILE = "/etc/exim4/update-exim4.conf.conf";
    private static final String EXIM_TEMPLATE_FILE = "/etc/exim4/exim4.conf.template";
    private static final String EXIM_AUTH_FILE = "/etc/exim4/passwd.client";
    private static final String EXIM_MACRO_FILE = "/etc/exim4/exim4.conf.localmacros";
    private static final String EXIM_LOG_FILE = "/var/log/exim4/mainlog";

    private static final String[] RECIPIENTS_PROTO = new String[0];

// THIS IS FOR ECLIPSE - @formatter:off

    private static final String EXIM_CONF_START =
        "# AUTOGENERATED BY UNTANGLE DO NOT MODIFY MANUALLY\n\n" +
        "dc_local_interfaces='127.0.0.1'\n" + 
        "dc_localdelivery='mail_spool'\n" + 
        "dc_relay_domains=''\n" + 
        "dc_minimaldns='false'\n" + 
        "dc_relay_nets=''\n" + 
        "dc_ignore_target_hosts='0.0.0.0 : 255.255.255.255 : 169.254.0.0/16'\n" + 
        "CFILEMODE='644'\n" + 
        "dc_use_split_config='false'\n" + 
        "dc_hide_mailname='true'\n" + 
        "dc_mailname_in_oh='true'\n";

    private static final String EXIM_MACRO_CONTENT =
        "# AUTOGENERATED BY UNTANGLE DO NOT MODIFY MANUALLY\n\n" +
        "AUTH_CLIENT_ALLOW_NOTLS_PASSWORDS='true'\n";
    
// THIS IS FOR ECLIPSE - @formatter:on

    private static final Object LOCK = new Object();

    private static MailSenderImpl MAIL_SENDER;

    public static boolean SessionDebug = false;

    private static final MimetypesFileTypeMap mimetypesFileTypeMap = new MimetypesFileTypeMap();

    private MailSettings settings;

    // This is the session used to send report mail inside the organization
    private Session mailSession;

    private MailSenderNetworkSettingsHook networkSettingsChangeHook = new MailSenderNetworkSettingsHook();

    private final Logger logger = LogManager.getLogger(getClass());

    /**
     * Constructor
     */
    private MailSenderImpl()
    {
        SettingsManager settingsManager = UvmContextFactory.context().settingsManager();
        MailSettings readSettings = null;
        String settingsFileName = System.getProperty("uvm.settings.dir") + "/untangle-vm/" + "mail.js";

        try {
            readSettings = settingsManager.load(MailSettings.class, settingsFileName);
        } catch (SettingsManager.SettingsException e) {
            logger.warn("Failed to load settings:", e);
        }

        /**
         * If there are still no settings, just initialize
         */
        if (readSettings == null) {
            logger.warn("No settings found - Initializing new settings.");

            settings = new MailSettings();
            String fromSender = UvmContextFactory.context().oemManager().getOemName().toLowerCase();
            String fromHostname = UvmContextFactory.context().networkManager().getNetworkSettings().getDomainName();
            settings.setFromAddress(fromSender + "@" + fromHostname);

            this.setSettings(settings);
        } else {
            /**
             * If the settings file  send method is RELAY then update it to DIRECT, re-sync
            */
            if (readSettings.getSendMethod() == MailSettings.SendMethod.RELAY) {
                readSettings.setSendMethod(SendMethod.DIRECT);
                this.setSettings(readSettings);
                logger.info("Changing mail settings to Direct Settings: " + this.settings.toJSONString());
            }
            this.settings = readSettings;
            logger.debug("Loading Settings: " + this.settings.toJSONString());
        }

        /**
         * If the settings file date is newer than the system files, re-sync
         * them
         */
        File settingsFile = new File(settingsFileName);
        File file1 = new File(EXIM_CONF_FILE);
        File file2 = new File(EXIM_AUTH_FILE);
        File file3 = new File(EXIM_TEMPLATE_FILE);
        if (settingsFile.lastModified() > file1.lastModified() || settingsFile.lastModified() > file2.lastModified() || settingsFile.lastModified() > file3.lastModified()) {

            logger.warn("Settings file newer than exim files, Syncing...");
            syncConfigFiles();
        }

        refreshSessions();
        logger.info("Initialized MailSender");
    }

    /**
     * Get the settings
     * 
     * @return The settings
     */
    public MailSettings getSettings()
    {
        return settings;
    }

    /**
     * Set the settings
     * 
     * @param newSettings
     *        The new settings
     */
    public void setSettings(final MailSettings newSettings)
    {
        /**
         * Save the settings
         */
        SettingsManager settingsManager = UvmContextFactory.context().settingsManager();
        try {
            settingsManager.save(System.getProperty("uvm.settings.dir") + "/" + "untangle-vm/" + "mail.js", newSettings);
        } catch (SettingsManager.SettingsException e) {
            logger.warn("Failed to save settings.", e);
            return;
        }

        /**
         * Change current settings
         */
        this.settings = newSettings;
        try {
            logger.debug("New Settings: \n" + new org.json.JSONObject(this.settings).toString(2));
        } catch (Exception e) {
        }

        this.syncConfigFiles();
    }

    /**
     * Update configuration files
     */
    public void syncConfigFiles()
    {
        refreshSessions();
        writeConfiguration();
    }

    /**
     * Called from UvmContextImpl at postInit time, after the networking manager
     * is up and runing
     */
    void postInit()
    {
        UvmContextFactory.context().hookManager().registerCallback(com.untangle.uvm.HookManager.NETWORK_SETTINGS_CHANGE, this.networkSettingsChangeHook);
    }

    /**
     * Returns the mail sender
     * 
     * @return The mail sender
     */
    static MailSenderImpl mailSender()
    {
        synchronized (LOCK) {
            if (null == MAIL_SENDER) {
                MAIL_SENDER = new MailSenderImpl();
            }
        }
        return MAIL_SENDER;
    }

    /**
     * Sends a message with attachments
     * 
     * @param recipients
     *        The recipient list
     * @param subject
     *        The subject
     * @param bodyHTML
     *        The body
     * @param extraLocations
     *        Extra locations
     * @param extras
     *        Extras stuff
     */
    public void sendMessageWithAttachments(String[] recipients, String subject, String bodyHTML, List<String> extraLocations, List<File> extras)
    {
        if (extraLocations == null && extras == null) {
            // Do this simplest thing.  Shouldn't be used. XX
            sendSimple(mailSession, recipients, subject, bodyHTML, null, null);
            return;
        } else if ((extraLocations == null && extras != null) || (extraLocations != null && extras == null) || (extraLocations.size() != extras.size())) {
            throw new IllegalArgumentException("sendReports mismatch of locations and extras");
        }

        List<MimeBodyPart> parts = new ArrayList<>();

        try {
            for (int i = 0; i < extras.size(); i++) {
                String location = extraLocations.get(i);
                File extra = extras.get(i);
                DataSource ds = new FileDataSource(extra);
                ((FileDataSource) ds).setFileTypeMap(mimetypesFileTypeMap);
                DataHandler dh = new DataHandler(ds);
                MimeBodyPart part = new MimeBodyPart();
                part.setDataHandler(dh);
                part.setHeader("Content-Location", location);
                part.setFileName(extra.getName());
                parts.add(part);
            }
        } catch (MessagingException x) {
            logger.error("Unable to parse extras", x);
            return;
        }

        sendMixed(mailSession, recipients, subject, bodyHTML, parts);
    }

    /**
     * Send a message
     * 
     * @param recipients
     *        The recipient list
     * @param subject
     *        The subject
     * @param bodyText
     *        The body
     */
    public void sendMessage(String[] recipients, String subject, String bodyText)
    {
        sendMessageWithAttachment(recipients, subject, bodyText, null);
    }

    /**
     * Send an HTML message
     * 
     * @param recipients
     *        The recipient list
     * @param subject
     *        The subject
     * @param bodyHtml
     *        The body
     * @return The result
     */
    public boolean sendHtmlMessage(String[] recipients, String subject, String bodyHtml)
    {
        return sendSimpleHtml(mailSession, recipients, subject, bodyHtml);
    }

    /**
     * See doc on interface
     * 
     * @param msgStream
     * @return result
     */
    public boolean sendMessage(InputStream msgStream)
    {
        //TODO bscott Need better error handling
        //TODO bscott by using JavaMail, we don't seem to be able to have
        //     a null ("<>") MAIL FROM.  This is a violation of some spec
        //     or another, which declares that the envelope from should
        //     be blank for notifications (so other servers don't send
        //     dead letters causing a loop).

        MimeMessage msg = streamToMIMEMessage(msgStream);

        if (msg == null) {
            return false;
        }

        //Send the message
        try {
            dosend(mailSession, msg);
            logIt(msg);
            return true;
        } catch (Exception ex) {
            logger.warn("Unable to send Message", ex);
            return false;
        }
    }

    /**
     * See doc on interface
     * 
     * @param msgStream
     * @param rcptStrs
     * @return result
     */
    public boolean sendMessage(InputStream msgStream, String... rcptStrs)
    {
        //First, convert the addresses
        Address[] addresses = parseAddresses(rcptStrs);
        if (addresses == null || addresses.length == 0) {
            logger.warn("No recipients for email");
            return false;
        }

        MimeMessage msg = streamToMIMEMessage(msgStream);

        if (msg == null) {
            return false;
        }

        //Send the message
        try {
            dosend(mailSession, msg, addresses);
            logIt(msg);
            return true;
        } catch (Exception ex) {
            logger.warn("Unable to send Message", ex);
            return false;
        }
    }

    /**
     * See doc on interface
     * 
     * @param recipients
     * @param subject
     * @param parts
     */
    public void sendMessage(String[] recipients, String subject, List<Map<MessagePartsField, String>> parts)
    {
        sendMultiPart(mailSession, recipients, subject, parts);

    }

    /**
     * Send a test message
     * 
     * @param recipient
     *        The recipient
     * @return The send result
     */
    public String sendTestMessage(String recipient)
    {
        UvmContext context = UvmContextFactory.context();
        Map<String, String> i18nMap = context.languageManager().getTranslations("untangle");
        String companyName = context.brandingManager().getCompanyName();
        I18nUtil i18nUtil = new I18nUtil(i18nMap);
        String testMessageSubject = i18nUtil.tr("{0} Server Test Message", companyName);
        String testMessageBody = i18nUtil.tr("Success!") + "\r\n\r\n" + i18nUtil.tr("This automated message was generated by the {0} Server{1}to confirm that your email settings are correct.", new Object[] { companyName, "\r\n" }) + "\r\n\r\n";
        BufferedReader br = null;
        try {
            File f = new File(EXIM_LOG_FILE);
            br = new BufferedReader(new FileReader(f));
            long l = f.length();
            br.skip(l); // go to the end of the logs

            // this will contain the messageId after the attempt to send it
            final List<String> messageId = new ArrayList<>();

            sendSimple(mailSession, new String[] { recipient }, testMessageSubject, testMessageBody, null, messageId);

            // wait until SMTPTransport finishes sending the email (it will
            // notify from a callback)
            synchronized (messageId) {
                messageId.wait(20000);
            }

            // after sending the message, check the new logs
            List<String> lines = new ArrayList<>();
            String str = br.readLine();
            while (str != null) {
                lines.add(str);
                str = br.readLine();
            }

            String logId = getMessageIdFromLog(messageId, lines);
            if (logId == null) {
                return i18nUtil.tr("Message failed to send.");
            }

            //we need to wait until exim finishes processing this email (flushing it now would not work,
            // since it might result in having 2 processes trying to access the same email)
            String what = UvmContextFactory.context().execManager().execOutput("exiwhat");
            int countDown = 20;
            while (what == null || what.contains(logId) && countDown > 0) {
                Thread.sleep(1000);
                what = UvmContextFactory.context().execManager().execOutput("exiwhat");
                countDown--;
            }

            //force sending of this email now (if previous emails failed for this host, 
            //the email is currently queued waiting for a timeout)
            String strM = UvmContextFactory.context().execManager().execOutput("exim -M " + logId);

            //String log = UvmContextFactory.context().execManager().execOutput("exim -Mvl "+logId);
            //now read the rest of the logs
            str = br.readLine();
            while (str != null) {
                lines.add(str);
                str = br.readLine();
            }

            return getMessage(logId, lines);

        } catch (IOException e) {
            return e.getMessage();
        } catch (InterruptedException e) {
            return e.getMessage();
        } finally {
            try {
                if (br != null) br.close();
            } catch (IOException x) {
            }
        }
    }

    /**
     * Gets a MIME message from a stream. Returns null if message could not be
     * created, and logs any errors
     * 
     * @param in
     *        Input stream
     * @return The message or null for failure
     */
    private MimeMessage streamToMIMEMessage(InputStream in)
    {
        try {
            MimeMessage msg = new MimeMessage(mailSession, in);
            msg.setHeader("X-Mailer", Mailer);
            return msg;
        } catch (Exception ex) {
            logger.error("Unable to convert input stream to MIMEMessage", ex);
            return null;
        }
    }

    /**
     * Writes out the new exim config files when the mali settings change.
     */
    private void writeConfiguration()
    {
        NetworkSettings netSettings = UvmContextFactory.context().networkManager().getNetworkSettings();
        String hostName = null;
        if (netSettings != null) hostName = netSettings.getHostName();
        if (hostName == null) {
            logger.warn("null hostname, using untangle-server");
            hostName = "untangle-server";
        }

        StringBuilder sb = new StringBuilder();
        sb.append(EXIM_CONF_START);

        sb.append("dc_other_hostnames='");
        sb.append(hostName);
        sb.append("'\n");

        sb.append("dc_readhost='");
        sb.append(hostName);
        sb.append("'\n");

        if (settings.getSendMethod() == MailSettings.SendMethod.DIRECT) {
            /**
             * Send mail directly using MX Records
             */
            sb.append("dc_eximconfig_configtype='");
            sb.append("internet");
            sb.append("'\n");

            sb.append("dc_smarthost=''\n");

            /**
             * Substitute the port in the exim template Set it back to 25 in
             * case it was previously configured to something else in smarthost
             */
            // remove all "  port = xx"
            String cmd1 = "/bin/sed -e \"/..port.=.[0-9].*$/d\" -i " + EXIM_TEMPLATE_FILE;
            UvmContextFactory.context().execManager().exec(cmd1);
            // insert new "  port = xx"
            String cmd2 = "/bin/sed -e \"s|  driver = smtp|  driver = smtp\\n  port = " + 25 + "|g\" -i " + EXIM_TEMPLATE_FILE;
            UvmContextFactory.context().execManager().exec(cmd2);
        } else {
            /**
             * Send mail to smarthost
             */
            sb.append("dc_eximconfig_configtype='");
            sb.append("satellite");
            sb.append("'\n");

            /**
             * If we're doing cloud relay, we must use 127.0.0.2 because exim
             * knows that 127.0.0.1 is the local host, and it gets mad and
             * freezes the mail. Removing "dc_local_interfaces='127.0.0.1'\n"
             * from the configuration also solves the problem, but then exim
             * listens on all interfaces. My solution was to have xinetd only
             * bind to 127.0.0.2 which linux loopback magic seems to allow. So
             * it looks crazy but actually works.
             */
            String targetHost = null;
            if (settings.getSendMethod() == MailSettings.SendMethod.CUSTOM) targetHost = settings.getSmtpHost();
            if (settings.getSendMethod() == MailSettings.SendMethod.RELAY) targetHost = "127.0.0.2"; // dot-two is NOT a typo

            sb.append("dc_smarthost='");
            sb.append(targetHost);
            sb.append("'\n");

            /**
             * write auth file
             */
            String user = settings.getAuthUser();
            if ("".equals(user)) user = null;
            String pass = settings.getAuthPass();
            if ("".equals(pass)) pass = null;

            if ((user == null && pass != null) || (user != null && pass == null)) {
                logger.warn("SMTP AUTH user/pass -- only one set, ignoring");
                user = null;
                pass = null;
            } else if (user != null) {
                StringBuilder sbpasswd = new StringBuilder();
                sbpasswd.append("*");
                sbpasswd.append(":");
                sbpasswd.append(user);
                sbpasswd.append(":");
                sbpasswd.append(pass);
                sbpasswd.append("\n");
                this.writeFile(sbpasswd, EXIM_AUTH_FILE);
            } else if (user == null && pass == null) {
                StringBuilder blank = new StringBuilder();
                blank.append("");
                this.writeFile(blank, EXIM_AUTH_FILE);
            }

            /**
             * Substitute the port in the exim template
             */

            int targetPort = 0;
            if (settings.getSendMethod() == MailSettings.SendMethod.CUSTOM) targetPort = settings.getSmtpPort();
            if (settings.getSendMethod() == MailSettings.SendMethod.RELAY) targetPort = STUNNEL_RELAY_PORT;

            // remove all "  port = xx"
            String cmd1 = "/bin/sed -e \"/..port.=.[0-9].*$/d\" -i " + EXIM_TEMPLATE_FILE;
            UvmContextFactory.context().execManager().exec(cmd1);
            // insert new "  port = xx"
            String cmd2 = "/bin/sed -e \"s|  driver = smtp|  driver = smtp\\n  port = " + targetPort + "|g\" -i " + EXIM_TEMPLATE_FILE;
            UvmContextFactory.context().execManager().exec(cmd2);
        }

        this.writeFile(sb, EXIM_CONF_FILE);

        StringBuilder macro_sb = new StringBuilder();
        macro_sb.append(EXIM_MACRO_CONTENT);

        this.writeFile(macro_sb, EXIM_MACRO_FILE);

        /**
         * touch all files so we know that a sync has occurred
         */
        new File(EXIM_AUTH_FILE).setLastModified(System.currentTimeMillis());
        new File(EXIM_TEMPLATE_FILE).setLastModified(System.currentTimeMillis());
        new File(EXIM_CONF_FILE).setLastModified(System.currentTimeMillis());
        new File(EXIM_MACRO_FILE).setLastModified(System.currentTimeMillis());

        // remove any paniclog from previous configs
        if (new File("/var/log/exim4/paniclog").exists()) {
            UvmContextFactory.context().execManager().exec("rm -rf /var/log/exim4/paniclog");
        }

        // restart exim
        // run it in the background because this runs whenever networking is saved
        // and this takes several seconds
        try{
            UvmContextFactory.context().execManager().execEvil(EXIM_CMD_RESTART_EXIM + " &");
        }catch( Exception e){
            logger.warn("error calling " + EXIM_CMD_RESTART_EXIM, e);
        }

    }

    /**
     * Called when settings updated.
     */
    private void refreshSessions()
    {
        Properties commonProps = new Properties();

        commonProps.put(MAIL_FROM_PROP, settings.getFromAddress());
        commonProps.put(MAIL_ENVELOPE_FROM_PROP, settings.getFromAddress());
        commonProps.put(MAIL_TRANSPORT_PROTO_PROP, "smtp");

        commonProps.put(MAIL_HOST_PROP, "localhost");
        // Sometimes Java can't find our name, and exim allows connections
        // from localhost so just hardwire it.
        commonProps.put(MAIL_SMTP_LOCALHOST_PROP, "localhost");

        Properties reportProps = (Properties) commonProps.clone();
        mailSession = Session.getInstance(reportProps);
    }

    /**
     * Make an attachment from a list of byte buffers
     * 
     * @param list
     *        The buffer list
     * @return The attachment
     */
    private MimeBodyPart makeAttachmentFromList(List<ByteBuffer> list)
    {
        if (list == null) return null;

        int bodySize = 0;
        for (Iterator<ByteBuffer> iter = list.iterator(); iter.hasNext();) {
            ByteBuffer buf = iter.next();
            bodySize += buf.remaining();
        }
        byte[] text = new byte[bodySize];
        int pos = 0;
        for (Iterator<ByteBuffer> iter = list.iterator(); iter.hasNext();) {
            ByteBuffer buf = iter.next();
            int size = buf.remaining();
            buf.get(text, pos, size);
            pos += size;
        }

        try {
            MimeBodyPart attachment = new MimeBodyPart(new InternetHeaders(), text);
            return attachment;
        } catch (MessagingException x) {
            logger.error("Unable to make attachment", x);
            return null;
        }
    }

    /**
     * Parse a String array into an Address array
     * 
     * @param addrStrings
     *        The address Strings
     * @return The Address array
     */
    private Address[] parseAddresses(String[] addrStrings)
    {
        List<Address> ret = new ArrayList<>();
        for (String s : addrStrings) {
            try {
                for (Address addr : InternetAddress.parse(s, false)) {
                    InternetAddress inetAddr = (InternetAddress) addr;
                    if (inetAddr.getAddress() != null && !"".equals(inetAddr.getAddress()) && !"<>".equals(inetAddr.getAddress())) {
                        ret.add(inetAddr);
                    }
                }
            } catch (Exception ex) {
                logger.warn("Unable to parse \"" + s + "\" into email address");
            }
        }
        return ret.toArray(new Address[ret.size()]);
    }

    /**
     * Prepare a message
     * 
     * @param session
     *        The session
     * @param to
     *        The recipient
     * @param subject
     *        The subject
     * @return The message
     */
    private Message prepMessage(Session session, String[] to, String subject)
    {
        Message msg = new MimeMessage(session);

        // come up with all recipients
        Address[][] addrs = new Address[to.length][];
        for (int i = 0; i < to.length; i++) {
            try {
                addrs[i] = InternetAddress.parse(to[i], false);
            } catch (AddressException x) {
                logger.error("Failed to parse receipient address " + to[i] + ", ignoring");
                addrs[i] = null;
            }
        }
        int addrCount = 0;
        for (int i = 0; i < addrs.length; i++)
            if (addrs[i] != null) addrCount += addrs[i].length;
        if (addrCount == 0) {
            logger.warn("No recipients for email, ignoring");
            return null;
        }

        Address[] recipients = new Address[addrCount];
        for (int i = 0, c = 0; i < addrs.length; i++) {
            if (addrs[i] != null) {
                for (int j = 0; j < addrs[i].length; j++)
                    recipients[c++] = addrs[i][j];
            }
        }

        try {
            msg.setRecipients(Message.RecipientType.TO, recipients);
            // msg.setRecipients(Message.RecipientType.CC, InternetAddress.parse(cc, false));
            // msg.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(bcc, false));
            msg.setFrom();
            msg.setSubject(subject);
            msg.setHeader("X-Mailer", Mailer);
            msg.setSentDate(new Date());
            return msg;
        } catch (MessagingException x) {
            logger.error("Unable to send message", x);
            return null;
        }
    }

    /**
     * Log a message
     * 
     * @param msg
     *        The message
     * @throws MessagingException
     */
    private void logIt(Message msg) throws MessagingException
    {
        if (logger.isInfoEnabled()) {
            StringBuffer sb = new StringBuffer("Successfully sent message '");
            sb.append(msg.getSubject());
            sb.append("' to ");
            Address[] peeps = msg.getAllRecipients();
            if (peeps == null || peeps.length == 0) {
                sb.append(" nobody!");
            } else {
                sb.append(peeps.length);
                sb.append(" recipients (");
                for (int i = 0; i < peeps.length; i++) {
                    if (i > 0) sb.append(", ");
                    sb.append(peeps[i]);
                }
                sb.append(")");
            }
            logger.info(sb.toString());
        }
    }

    /**
     * Send a simple message
     * 
     * @param session
     *        The session
     * @param to
     *        The recipient
     * @param subject
     *        The subject
     * @param bodyText
     *        The body
     * @param attachment
     *        The attachment
     * @param messageId
     *        The message ID
     * @return False on error, otherwise true
     */
    protected boolean sendSimple(Session session, String[] to, String subject, String bodyText, MimeBodyPart attachment, final List<String> messageId)
    {
        if (SessionDebug) session.setDebug(true);

        // construct the message
        Message msg = prepMessage(session, to, subject);
        if (msg == null)
        // Nevermind after all.
            return true;

        try {
            if (attachment == null) {
                msg.setText(bodyText);
            } else {
                MimeBodyPart main = new MimeBodyPart();
                main.setText(bodyText);
                main.setDisposition(Part.INLINE);
                Multipart mp = new MimeMultipart();
                mp.addBodyPart(main);
                mp.addBodyPart(attachment);
                msg.setContent(mp);
            }

            // send it
            dosend(session, msg, msg.getAllRecipients(), messageId);

            logIt(msg);
            return true;
        } catch (MessagingException x) {
            logger.warn("Unable to send message", x);
            return false;
        }
    }

    /**
     * Send a simple HTML message
     * 
     * @param session
     *        The session
     * @param to
     *        The recipient
     * @param subject
     *        The subject
     * @param bodyHTML
     *        The body
     * @return False on error, otherwise true
     */
    protected boolean sendSimpleHtml(Session session, String[] to, String subject, String bodyHTML)
    {
        if (SessionDebug) session.setDebug(true);

        // construct the message
        Message msg = prepMessage(session, to, subject);
        if (msg == null)
        // Nevermind after all.
            return true;

        try {
            msg.setContent(bodyHTML, "text/html");

            // send it
            dosend(session, msg);
            logIt(msg);
            return true;
        } catch (MessagingException x) {
            logger.warn("Unable to send message", x);
            return false;
        }
    }

    /**
     * Send related (whatever that means)
     * 
     * @param session
     *        The session
     * @param to
     *        The recipient
     * @param subject
     *        The subject
     * @param bodyHTML
     *        The body
     * @param extras
     *        The extras
     * @return False on error, otherwise true
     */
    protected boolean sendRelated(Session session, String[] to, String subject, String bodyHTML, List<MimeBodyPart> extras)
    {
        if (SessionDebug) session.setDebug(true);

        // construct the message
        Message msg = prepMessage(session, to, subject);
        if (msg == null)
        // Nevermind after all.
            return true;

        try {
            Multipart mp = new MimeMultipart("related");
            MimeBodyPart main = new MimeBodyPart();
            main.setContent(bodyHTML, "text/html");
            // main.setDisposition(Part.INLINE);
            mp.addBodyPart(main);
            for (MimeBodyPart part : extras)
                mp.addBodyPart(part);
            msg.setContent(mp);

            // send it
            dosend(session, msg);
            logIt(msg);
            return true;
        } catch (MessagingException x) {
            logger.warn("Unable to send message", x);
            return false;
        }
    }

    /**
     * Send mixed
     * 
     * @param session
     *        The session
     * @param to
     *        The recipient
     * @param subject
     *        The subject
     * @param bodyText
     *        The body
     * @param extras
     *        The extras
     * @return False on error, otherwise true
     */
    protected boolean sendMixed(Session session, String[] to, String subject, String bodyText, List<MimeBodyPart> extras)
    {
        if (SessionDebug) session.setDebug(true);

        // construct the message
        Message msg = prepMessage(session, to, subject);
        if (msg == null)
        // Nevermind after all.
            return true;

        try {
            Multipart mp = new MimeMultipart("mixed");
            MimeBodyPart main = new MimeBodyPart();
            main.setText(bodyText);
            main.setHeader("Content-Type", "text/html");
            main.setDisposition(Part.INLINE);
            mp.addBodyPart(main);
            for (MimeBodyPart part : extras)
                mp.addBodyPart(part);
            msg.setContent(mp);

            // send it
            dosend(session, msg);
            logIt(msg);
            return true;
        } catch (MessagingException x) {
            logger.warn("Unable to send message", x);
            return false;
        }
    }

    /**
     * Send a multi part message
     * 
     * @param session
     *        The session
     * @param to
     *        The recipient
     * @param subject
     *        The subject
     * @param parts
     *        The parts
     * @return False on error, otherwise true
     */
    protected boolean sendMultiPart(Session session, String[] to, String subject, List<Map<MessagePartsField, String>> parts)
    {
        if (SessionDebug) session.setDebug(true);

        // construct the message
        Message msg = prepMessage(session, to, subject);
        if (msg == null)
        // Nevermind after all.
            return true;

        try {
            // Maybe mixed
            Multipart mimeMultipartRelated = new MimeMultipart("related");
            Multipart mimeMultipartAlternative = new MimeMultipart("alternative");

            MimeBodyPart mimeBodyPart = null;
            mimeBodyPart = new MimeBodyPart();
            mimeBodyPart.setContent(mimeMultipartAlternative);
            mimeMultipartRelated.addBodyPart(mimeBodyPart);

            // Add text and html body
            for (int i = 0; i < parts.size(); i++) {
                Map<MessagePartsField, String> part = parts.get(i);
                if (part.get(MessagePartsField.TEXT) != null) {
                    mimeBodyPart = new MimeBodyPart();
                    mimeBodyPart.setText(part.get(MessagePartsField.TEXT));
                    mimeBodyPart.setHeader("Content-Type", "text/plain; charset=utf-8");
                    mimeMultipartAlternative.addBodyPart(mimeBodyPart);
                } else if (part.get(MessagePartsField.HTML) != null) {
                    mimeBodyPart = new MimeBodyPart();
                    mimeBodyPart.setText(part.get(MessagePartsField.HTML));
                    mimeBodyPart.setHeader("Content-Type", "text/html; charset=utf-8");
                    mimeMultipartAlternative.addBodyPart(mimeBodyPart);
                } else {
                    String filename = part.get(MessagePartsField.FILENAME);
                    if (filename != null) {
                        File attachmentFile = new File(filename);
                        String mimetype = new MimetypesFileTypeMap().getContentType(attachmentFile);
                        DataSource ds = new FileDataSource(attachmentFile);
                        ((FileDataSource) ds).setFileTypeMap(mimetypesFileTypeMap);
                        DataHandler dh = new DataHandler(ds);
                        mimeBodyPart = new MimeBodyPart();
                        mimeBodyPart.setDataHandler(dh);
                        String contentType = null;
                        try {
                            contentType = Files.probeContentType(Paths.get(filename));
                        } catch (Exception e) {
                            logger.warn("paths exception " + e);
                            contentType = dh.getContentType();
                        }
                        mimeBodyPart.setHeader("Content-Type", contentType + "; name=\"" + attachmentFile.getName() + "\"");
                        if (part.get(MessagePartsField.CID) != null) {
                            mimeBodyPart.setHeader("Content-ID", "<" + part.get(MessagePartsField.CID) + ">");
                        }
                        mimeMultipartRelated.addBodyPart(mimeBodyPart);
                    }
                }
            }

            msg.setContent(mimeMultipartRelated);
            dosend(session, msg);
            logIt(msg);
            return true;
        } catch (MessagingException x) {
            logger.error("Unable to parse extras", x);
            return false;
        }
    }

    /**
     * Send mixed error log
     * 
     * @param session
     *        The session
     * @param to
     *        The recipient
     * @param subject
     *        The subject
     * @param bodyText
     *        The body
     * @param extras
     *        The extras
     * @return False on error, otherwise true
     */
    protected boolean sendMixedErrorLog(Session session, String[] to, String subject, String bodyText, List<MimeBodyPart> extras)
    {
        if (SessionDebug) session.setDebug(true);

        // construct the message
        Message msg = prepMessage(session, to, subject);
        if (msg == null) return true;

        try {
            Multipart mp = new MimeMultipart("mixed");
            MimeBodyPart main = new MimeBodyPart();
            main.setHeader("Content-Type", "text/plain");
            main.setDisposition(Part.INLINE);
            main.setText(bodyText, "us-ascii");
            mp.addBodyPart(main);
            for (MimeBodyPart part : extras)
                mp.addBodyPart(part);
            msg.setContent(mp);

            // send it
            dosend(session, msg);
            logIt(msg);
            return true;
        } catch (MessagingException x) {
            logger.warn("Unable to send message", x);
            return false;
        }
    }

    /**
     * Send a message with attachments
     * 
     * @param recipients
     *        The recipients
     * @param subject
     *        The subject
     * @param bodyText
     *        The body
     * @param attachment
     *        The attachments
     */
    private void sendMessageWithAttachment(String[] recipients, String subject, String bodyText, List<ByteBuffer> attachment)
    {
        if (attachment == null) {
            sendSimple(mailSession, recipients, subject, bodyText, null, null);
        } else {
            MimeBodyPart part = makeAttachmentFromList(attachment);
            sendSimple(mailSession, recipients, subject, bodyText, part, null);
        }
    }

    /**
     * Here's where we actually do the sending
     * 
     * @param session
     *        The session
     * @param msg
     *        The message
     * @throws MessagingException
     */
    private void dosend(Session session, Message msg) throws MessagingException
    {
        dosend(session, msg, msg.getAllRecipients(), null);
    }

    /**
     * Here's where we actually do the sending
     * 
     * @param session
     *        The session
     * @param msg
     *        The message
     * @param recipients
     *        The recipients
     * @throws MessagingException
     */
    private void dosend(Session session, Message msg, Address[] recipients) throws MessagingException
    {
        dosend(session, msg, recipients, null);
    }

    /**
     * Here's where we actually do the sending
     * 
     * @param session
     *        The session
     * @param msg
     *        The message
     * @param recipients
     *        The recipients
     * @param messageId
     *        The message ID
     * @throws MessagingException
     */
    private void dosend(Session session, Message msg, Address[] recipients, final List<String> messageId) throws MessagingException
    {
        SMTPTransport transport = null;
        TransportListener tl = null;
        try {
            transport = (SMTPTransport) session.getTransport();
            // We get the host from the session since it can differ (mv errors).
            String host = session.getProperty(MAIL_HOST_PROP);

            // if we want to get back the messageId (for searching exim logs afterwards)
            // we add a TransportListener
            if (messageId != null) {
                tl = new TransportListener()
                {
                    /**
                     * Handler for partially delivered message
                     * 
                     * @param arg0
                     *        The transport event
                     */
                    @Override
                    public void messagePartiallyDelivered(TransportEvent arg0)
                    {
                        synchronized (messageId) {
                            String id = getMessageId(arg0);
                            if (id != null) messageId.add(id);
                            messageId.notify();
                        }
                    }

                    /**
                     * Handler for not delivered message
                     * 
                     * @param arg0
                     *        The transport event
                     */
                    @Override
                    public void messageNotDelivered(TransportEvent arg0)
                    {
                        synchronized (messageId) {
                            String id = getMessageId(arg0);
                            if (id != null) messageId.add(id);
                            messageId.notify();
                        }
                    }

                    /**
                     * Handler for message delivered
                     * 
                     * @param arg0
                     *        The transport event
                     */
                    @Override
                    public void messageDelivered(TransportEvent arg0)
                    {
                        synchronized (messageId) {
                            String id = getMessageId(arg0);
                            if (id != null) messageId.add(id);
                            messageId.notify();
                        }
                    }
                };

                transport.addTransportListener(tl);
            }

            transport.connect(host, null, null);
            transport.sendMessage(msg, recipients);
        } catch (MessagingException x) {
            throw x;
        } catch (Exception x) {
            // Uh oh...
            logger.error("Unexpected exception in dosend", x);
            throw new MessagingException("Unexpected exception in dosend", x);
        } finally {
            try {
                if (transport != null) transport.removeTransportListener(tl);
            } catch (Exception x) {
            }
            try {
                if (transport != null) transport.close();
            } catch (MessagingException x) {
            }
        }
    }

    /**
     * Extract the message ID from a TransportEvent
     * 
     * @param arg0
     *        The transport event
     * @return The message ID
     */
    private String getMessageId(TransportEvent arg0)
    {
        try {
            Message message = arg0.getMessage();
            String[] headerId = message.getHeader("Message-ID");
            if (headerId.length > 0) {
                // the Id is enclosed by < > so we remove them
                return headerId[0].substring(1, headerId[0].length() - 1);
            }
        } catch (MessagingException e) {
        }
        return null;
    }

    /**
     * In exim logs, each mail has an ID. This method identifies the ID from a
     * given line of text.
     * 
     * @param line
     *        The line of text
     * @return The message ID or null if not found
     */
    private String getMessageIdFromLogLine(String line)
    {
        StringTokenizer st = new StringTokenizer(line, " ");
        if (st.countTokens() > 3) {
            st.nextToken();
            st.nextToken();
            return st.nextToken();
        }
        return null;
    }

    /**
     * Parse the exim log lines in order to find the logs regarding a given
     * message identified by an ID
     * 
     * @param messageId
     *        The message ID
     * @param logLines
     *        The log lines
     * @return The log ID
     */
    private String getMessageIdFromLog(List<String> messageId, List<String> logLines)
    {

        String logId = null;
        if (messageId.size() > 0) {
            for (int i = 0; i < logLines.size(); i++) {
                String line = logLines.get(i);
                //find the first line that mentions the MessageID
                //and extract the exim ID
                if (line.contains(messageId.get(0))) {
                    logId = getMessageIdFromLogLine(line);
                    return logId;
                }
            }
        }
        return null;
    }

    /**
     * Parse the exim log lines in order to find the logs regarding a given
     * message identified by an ID
     * 
     * @param logId
     *        The log ID
     * @param logLines
     *        The log lines
     * @return The logs
     */
    private String getMessage(String logId, List<String> logLines)
    {

        String msg = "";
        for (int i = 0; i < logLines.size(); i++) {
            String line = logLines.get(i);
            //find the first line that mentions the MessageID
            //and extract the exim ID
            //            if (line.contains(messageId.get(0))){
            //                logId = getMessageIdFromLog(line);
            //                continue;
            //            }
            //from all the lines referring to the logId, extract the useful message
            if (logId != null) {
                if (line.contains(logId)) {
                    if (line.contains("<=")) {
                        continue;
                    }
                    // a line containing => indicates that the mail has been successfully sent 
                    if (line.contains("=>")) {
                        logger.info("Test email succcesfully sent.");
                        return "Completed";
                    }
                    if (!line.contains("retry time not reached for any host")) { // this is just a info, we do not add it to the message
                        int pos = line.indexOf(logId);
                        msg += line.substring(pos + logId.length()) + " ";
                    }
                }
            }
        }
        logger.info("Test email msg:" + msg);
        return msg;
    }

    /**
     * Write a string builder to a file
     * 
     * @param sb
     *        The string builder
     * @param fileName
     *        The filename
     */
    private void writeFile(StringBuilder sb, String fileName)
    {
        BufferedWriter out = null;

        /* Open up the interfaces file */
        try {
            String data = sb.toString();

            out = new BufferedWriter(new FileWriter(fileName));
            out.write(data, 0, data.length());
        } catch (Exception ex) {
            /*
             * XXX May need to catch this exception, restore defaults then try
             * again
             */
            logger.error("Error writing file " + fileName + ":", ex);
        }

        try {
            if (out != null) out.close();
        } catch (Exception ex) {
        }
    }

    /**
     * Hook for changes to network settings
     */
    private class MailSenderNetworkSettingsHook implements HookCallback
    {
        /**
         * Get the hook name
         * 
         * @return The hook name
         */
        public String getName()
        {
            return "mail-sender-network-settings-change-hook";
        }

        /**
         * Hook callback
         * 
         * @param args
         *        Callback args
         */
        public void callback(Object... args)
        {
            syncConfigFiles();
        }
    }
}
