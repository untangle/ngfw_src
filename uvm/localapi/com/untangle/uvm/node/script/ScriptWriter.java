/*
 * Copyright (c) 2003-2007 Untangle, Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Untangle, Inc. ("Confidential Information"). You shall
 * not disclose such Confidential Information.
 *
 * $Id$
 */

package com.untangle.uvm.node.script;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.InputStreamReader;

import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.apache.log4j.Logger;

import com.untangle.uvm.UvmContextFactory;

/* XXX This should probably be abstracted, up to a script writer and then have a
 * class that is a shell script writer
 */
public class ScriptWriter
{
    private final Logger logger = Logger.getLogger(getClass());

    public static final String COMMENT         = "#";

    /* Split so that other script writers can use the constant */
    public static final String METAVIZE_HEADER = "AUTOGENERATED BY UNTANGLE DO NOT MODIFY\n\n";
    private static final String SCRIPT_HEADER   = "#!/bin/sh\n\n" + COMMENT + METAVIZE_HEADER;

    private static final String EXPORT_FLAG     = "export";

    private static final String EMPTY_HEADER[]  = new String[0];

    private static final Pattern ESCAPE_PATTERN;
    private static final String ESCAPE_STRING = "'";
    /* For shell, single ticks even escaped single ticks are not
     * allowed in a string of single ticks.  The only option is to
     * close the single tick, add one in double ticks and then reopen it */
    private static final String ESCAPE_REPLACEMENT = "'\"'\"'";

    private final StringBuilder sb;

    public ScriptWriter()
    {
        this( EMPTY_HEADER );
    }

    public ScriptWriter( String header[] )
    {
        this.sb = new StringBuilder();
        this.sb.append( header());

        appendLines( header );
    }

    public void appendLine()
    {
        this.sb.append( "\n" );
    }

    /** Kind of a silly helper functions to avoid "\n" everywhere " */
    public void appendLine( String text )
    {
        this.sb.append( text + "\n" );
    }

    public void appendLines( String ... text )
    {
        for ( String line : text ) appendLine( line );
    }

    public void appendComment( String text )
    {
        for ( String line : text.split( "\n" )) this.sb.append( comment() + " " + line + "\n" );
    }
    
    // Really only for shell scripts
    public void appendVariable( String variable, boolean value )
    {
        appendVariable( variable, String.valueOf( value ));
    }

    public void appendVariable( String variable, boolean value, boolean isGlobal )
    {
        appendVariable( variable, String.valueOf( value ), isGlobal );
    }

    public void appendVariable( String variable, int value )
    {
        appendVariable( variable, String.valueOf( value ));
    }

    public void appendVariable( String variable, int value, boolean isGlobal )
    {
        appendVariable( variable, String.valueOf( value ), isGlobal );
    }
    
    // This should be rewritten so all of these methods are final, and then
    // the method that takes four arguments is protected.
    public void appendVariable( String variable, String value, boolean isGlobal )
    {
        appendVariable( variable, value, isGlobal, false );
    }

    public void appendVariable( String variable, String value )
    {
        appendVariable( variable, value, false, false );
    }

    /** Append a variable that is escaped, and global (exported) */
    public void appendGlobalEscapedVariable( String variable, String value )
    {
        appendVariable( variable, value, true, true );
    }

    /** Append a variable that is escaped, not global (exported) */
    public void appendEscapedVariable( String variable, String value )
    {
        appendVariable( variable, value, false, true );
    }

    private void appendVariable( String variable, String value, boolean isGlobal, boolean isEscaped )
    {
        if (( variable == null ) || ( value == null )) {
            logger.warn( "NULL variable[" + variable +"] or value[" + value + "], ignoring" );
            return;
        }

        variable = variable.trim();
        value    = value.trim();

        if ( variable.length() == 0 ) {
            /* This is a jenky way to get a stack trace */
            logger.warn( "Empty variable name, ignoring", new Exception());
            return;
        }

        String quotes = "\"";

        if ( isEscaped ) {
            /* Just in case it wasn't able to be compiled at startup, that should never
             * happpen, but just in case */
            if ( ESCAPE_PATTERN != null ) {
                value = ESCAPE_PATTERN.matcher( value ).replaceAll( ESCAPE_REPLACEMENT );
            }
            quotes = "'";
        }

        appendLine((( isGlobal ) ? EXPORT_FLAG + " " : "" ) + variable + "=" + quotes + value + quotes );
    }


    /* Structured this way so different script writers can use different comment indicators */
    protected String comment()
    {
        return COMMENT;
    }

    protected String header()
    {
        return SCRIPT_HEADER;
    }

    public String getContents()
    {
        return sb.toString();
    }

    public void writeFile( String fileName )
    {
        writeFile( fileName, null );
    }

    /**
     * Write out the file to filename, if permissions are non-null, then call chmod with permission
     * after writing the file
     */
    public void writeFile( String fileName, String permissions )
    {
        BufferedWriter out = null;

        /* Open up the interfaces file */
        try {
            String data = sb.toString();

            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
        }

        try {
            if ( out != null ) out.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }

        
        if ( permissions != null ) setPermissions( fileName, permissions );
    }

    /* ----------------- Private ----------------- */
    /* Modify the file permissions of a file */
    private void setPermissions( String fileName, String permissions )
    {
        if ( permissions == null ) return;

        try {
            Process p = UvmContextFactory.context().
                exec( new String[] { "/bin/chmod", permissions, fileName } );

            /* Read out standard error and input */
            String line;
            BufferedReader output = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            while (( line = output.readLine()) != null );
            output = new BufferedReader(new InputStreamReader(p.getInputStream()));
            while (( line = output.readLine()) != null );

            if ( p.waitFor() != 0 ) {
                logger.warn( "Unable to change permissions of " + fileName + " to [" + permissions + "]" );
            }
        } catch ( Exception e ) {
            logger.warn( "Unable to change permissions of " + fileName + " to [" + permissions + "]", e );
        }
    }

    static {
        Pattern pattern = null;

        try {
            pattern = Pattern.compile( ESCAPE_STRING );
        } catch ( PatternSyntaxException e ) {
            System.err.println( "Unable to compile pattern, using null" );
            pattern = null;
        }

        ESCAPE_PATTERN = pattern;
    }
}
