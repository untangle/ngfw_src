#!/bin/dash

exec 2> /dev/null

DNS_MASQ_CONF="/etc/dnsmasq.conf"
SINGLE_NIC_FILE="/etc/untangle-net-alpaca/single-nic-mode"
SINGLE_NIC_FLAG="/usr/share/untangle-arp-eater/flag"

PROPERTY_NET_CONF="com.untangle.networking.net-conf"
PROPERTY_BRIDGE_CONF="com.untangle.networking.bridge-conf"
PROPERTY_DNS_1="com.untangle.networking.dns-1"
PROPERTY_DNS_2="com.untangle.networking.dns-2"
PROPERTY_DEFAULT_GW="com.untangle.networking.default-gateway"
PROPERTY_DDNS_EN="com.untangle.networking.ddns-en"
PROPERTY_HOSTNAME="com.untangle.networking.hostname"
PROPERTY_DOMAIN_SUFFIX="com.untangle.networking.domain-suffix"
PROPERTY_DHCP_EN="com.untangle.networking.dhcp-enabled"
PROPERTY_DHCP_START="com.untangle.networking.dhcp-start"
PROPERTY_DHCP_END="com.untangle.networking.dhcp-end"
PROPERTY_DHCP_DEFAULT_GW="com.untangle.networking.dhcp-default-gateway"
PROPERTY_DNS_EN="com.untangle.networking.dns-enabled"
PROPERTY_DNS_LOCAL_DOMAIN="com.untangle.networking.dns-local-domain"
PROPERTY_DHCP_DNS_SERVERS="com.untangle.networking.dhcp-dns-servers"
PROPERTY_SINGLE_NIC_MODE="com.untangle.networking.single-nic-mode"

# This is the interface that has all of the aliases on it for PPPoE.
# In the bridge case, this is the name of the bridge for the external
# interface.  In the non-bridge case, this is the name of the
# interface that is being used to connect over PPPoE.
pppoe_interface()
{
    test -f /etc/network/interfaces || return
    
    ## Grab the provider.
    local t_provider=`awk '/ppp0/ { is_ppp = true }; /^[\t ]*provider/ { sub( /^[\t ]*provider[\t ]*/, "" ) ; if ( is_ppp == true ) print }' /etc/network/interfaces`

    ## check if there is actually a provider
    test -z "${t_provider}" && return
    
    ## Now grab the interface that is linked to this provider.
    t_provider="/etc/ppp/peers/${t_provider}"
    test -f ${t_provider} || return

    ## Now print out the name of the interface that is used
    awk --assign print_interface=true  --assign interface="" \
        '/^[ \t]*plugin rp-pppoe.so/ { interface=$0 ; sub( /[ \t]*plugin rp-pppoe.so[ \t]*/, "", interface ) } ; /^\# bridge_configuration:/ { print $3 ; print_interface = false ; exit } ; END { if ( print_interface && interface != "" ) print interface }' ${t_provider}
}

pppoe_awk_script()
{
    ## ppp_aliases is broken out so that those always come second.
    cat <<'EOF'
/^[0-9]/ { interface = $2 ; sub( ":$", "", interface ) ; if ( interface != "ppp0" && interface != pppoe  ) { printf ":::%s", interface }} ;
/^ *inet.*brd.*scope global/ { if ( interface == pppoe ) { aliases = aliases ";" $2  } else { printf ";%s", $2 }} ;
/^ *inet.*peer.*scope global/ { ppp_aliases= ppp_aliases ";" $2 "/31" } ;
END { printf ":::%s%s%s", pppoe_name, aliases, ppp_aliases ; printf "\n"  }
EOF
}

## This returns a string of the form:
## [:::<interface-name>[;<ip-address>/<netmask-cidr>]*]*
network_configuration()
{                   
    ## Determine if this needs to glob together the configuration for another interface.
    local t_pppoe
    

    ## Not sure why, but 'local t_pppoe=`pppoe_interface`' doesn't work here.
    t_pppoe=$1
    
    if [ -z "${t_pppoe}" ]; then
        ip addr show | awk '/^[0-9]/ { interface = $2 ; sub( ":$", "", interface ) ; printf ":::%s", interface } ; /^ *inet.*brd.*scope global/ { printf ";%s", $2 } ;  END { printf "\n"  }' 
    else
        ## This is the name to tell netcap.
        local t_pppoe_name="ppp0"

        ## If using a bridge, then the addresses should all be on the bridge.
        test -d "/sys/class/net/${t_pppoe}/bridge" && t_pppoe_name="${t_pppoe}"
        
        ## Dump the list of interfaces the same way, but this time (script is just too long
        ## to put in on the command line, and it is too annoying to create a separate file.
        ip addr show | awk --assign pppoe="${t_pppoe}" --assign pppoe_name="${t_pppoe_name}" "`pppoe_awk_script`"
    fi
}

## This returns a string of the form:
## [:::<bridge-name>[;<bridge-interface]*]*
bridge_configuration()
{
    ## Determine if this needs to glob together the configuration for another interface.
    local t_pppoe
    t_pppoe=$1

    if [ -z "${t_pppoe}" ]; then
        find /sys/class/net/ -follow -maxdepth 3 -path '*/brif/*' 2>/dev/null \
            | sort \
            | awk '{ split( $0, path, "/" ) ; if ( path[5] != bridge ) { bridge = path[5] ; printf ":::%s", bridge } ; printf ";%s", path[7] } END { printf "\n" }'
    else
        ## Append ppp0 to whatever the ppp0 interface is.
        find /sys/class/net/ -follow -maxdepth 3 -path '*/brif/*' 2>/dev/null \
            | sort \
            | awk --assign pppoe_interface=${t_pppoe} '{ split( $0, path, "/" ) ; if ( path[5] != bridge ) { bridge = path[5] ; printf ":::%s", bridge; if ( bridge == pppoe_interface ) printf ";ppp0" } ; printf ";%s", path[7] } END { printf "\n" }'
    fi
}

## This may be incorrect if you have two links, but it isn't actually used
## by the system so it doesn't really matter.
get_default_gateway()
{
    ip route show table all | awk '/default/ { print $3 ; exit }'
}

## Here goes nothing, several calls to awk to accomplish what could be done in one.
get_dns_1()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk '/^server/ { sub( " *#.*", "" ); sub( "^server=", "" ) ; print  ; exit }' ${DNS_MASQ_CONF}
    fi
}

get_dns_2()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk -v dns_1=false '/^server/ { if ( dns_1 == "false" ) { dns_1 = "true" ; next } ; sub( " *#.*", "" ); sub( "^server=", "" ) ; print  ; exit }' ${DNS_MASQ_CONF}
    fi
}

get_dhcp_enabled()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        grep -q "dhcp-range" ${DNS_MASQ_CONF} && echo "true"
    fi
}

get_dhcp_start()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk '/^dhcp-range=/ { sub( "dhcp-range=", "" ) ; split( $0, v, "," )  ; print v[1] } ' ${DNS_MASQ_CONF}
    fi
}

get_dhcp_end()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk '/^dhcp-range=/ { sub( "dhcp-range=", "" ) ; split( $0, v, "," )  ; print v[2] } ' ${DNS_MASQ_CONF}
    fi
}

## This is the gateway the dhcp server would recommend in its leases.
get_dhcp_default_gateway()
{
    if [ -f ${DNS_MASQ_CONF} ] ; then
        awk '/^dhcp-option=3,/ { sub( "dhcp-option=3,", "" ) ; print } ' ${DNS_MASQ_CONF}
    fi
}

## This is the gateway the DNS Servers the DHCP server will recommend in its leases.
get_dhcp_dns_servers()
{
    if [ -f ${DNS_MASQ_CONF} ]; then
        awk '/^dhcp-option=6,/ { sub( "dhcp-option=6,", "" ) ; print } ' ${DNS_MASQ_CONF}
    fi
}

get_dns_enabled()
{
    if [ -f ${DNS_MASQ_CONF} ]; then
        grep -q '# DNS Server disabled, not saving hosts.' ${DNS_MASQ_CONF} || echo "true"
    fi
}

get_dns_local_domain()
{
    if [ -f ${DNS_MASQ_CONF} ]; then
        awk '/^domain=/ { sub( "domain=", "" ) ; print } ' ${DNS_MASQ_CONF}
    fi
}

get_is_ddns_running()
{
    # Either of these processes are running means dynamic dns is running.
    pgrep '(ddclient|no-ip)' > /dev/null 2>&1 && echo "true"
}

get_single_nic_mode()
{
    local t_single_nic_mode
    if [ -f "${SINGLE_NIC_FILE}" ] && [ -f "${SINGLE_NIC_FLAG}" ]; then
        t_single_nic_mode=`awk 'BEGIN { single_nic = "false" } ; { if ( $1 == "true" ) single_nic = $1 ; exit } ; END { print single_nic }' ${SINGLE_NIC_FILE} 2>/dev/null`

        if [ "${t_single_nic_mode}x" = "truex" ]; then
            ## As a secondary precaution, true / false won't do, this
            ## file must be present and contain a shared value.
            head -n 1 "${SINGLE_NIC_FLAG}"
        else
            echo "false"
        fi
    else
        echo "false"
    fi
}

get_domain_suffix()
{
    awk -v suffix=example.com '/^search/ { suffix=$2 ; exit }; END { print suffix }' /etc/resolv.conf
}

get_properties()
{
    local t_pppoe_interface
    ## Not sure why, but 'local t_pppoe_interface=`pppoe_interface`' doesn't work here.
    t_pppoe_interface=`pppoe_interface`

    echo "${PROPERTY_NET_CONF}=`network_configuration ${t_pppoe_interface}`"
    echo "${PROPERTY_BRIDGE_CONF}=`bridge_configuration ${t_pppoe_interface}`"
    echo "${PROPERTY_DNS_1}=`get_dns_1`"
    echo "${PROPERTY_DNS_2}=`get_dns_2`"
    echo "${PROPERTY_DEFAULT_GW}=`get_default_gateway`"
    echo "${PROPERTY_HOSTNAME}=`hostname`"
    echo "${PROPERTY_DOMAIN_SUFFIX}=`get_domain_suffix`"
    echo "${PROPERTY_DHCP_EN}=`get_dhcp_enabled`"
    echo "${PROPERTY_DHCP_START}=`get_dhcp_start`"
    echo "${PROPERTY_DHCP_END}=`get_dhcp_end`"
    echo "${PROPERTY_DHCP_DEFAULT_GW}=`get_dhcp_default_gateway`"
    echo "${PROPERTY_DHCP_DNS_SERVERS}=`get_dhcp_dns_servers`"
    echo "${PROPERTY_DNS_EN}=`get_dns_enabled`"
    echo "${PROPERTY_DNS_LOCAL_DOMAIN}=`get_dns_local_domain`"
    echo "${PROPERTY_DDNS_EN}=`get_is_ddns_running`"
    echo "${PROPERTY_SINGLE_NIC_MODE}=`get_single_nic_mode`"
}
 
get_properties   

exit 0

