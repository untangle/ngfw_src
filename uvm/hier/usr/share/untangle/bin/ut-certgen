#!/bin/dash

OPENSSL_CONF="@PREFIX@/usr/share/untangle/conf/ut-openssl.cnf"
OPENSSL_TOOL="/usr/bin/openssl"
CERT_PATH="/var/cache/untangle-https"
TEMP="/dev/shm"

UT_ROOT_PATH="/usr/share/untangle/settings/untangle-certificates"

# Since we call this script to generate mitm certificates on the fly we must
# use a random source that will not block.  All the security articles I found
# indicate /dev/urandom has plenty of entropy given what we're doing here.
RANDFILE="/dev/urandom"

show_usage()
{
echo " "
echo "  USAGE: https-certgen certfile subject [ alternates ]"
echo " "
echo "  certfile = www.domain.com"
echo "  subject = /C=US/ST=California/L=Sunnyvale/O=Untangle/OU=Security/CN=www.domain.com"
echo "  alternates = DNS:ftp.domain.com,DNS:mail.domain.com"
echo " "
}

# First argument should be the destination filename for the new cert.  Since
# the origin cert CN might include a wildcard, the Java code will first
# convert the filename to all lower case and the replace any *'s with X's
if [ -z "$1" ]; then
    show_usage
    exit 1
fi

# Second argument should be the subject field for the generated certificate
if [ -z "$2" ]; then
    show_usage
    exit 2
fi

# Third argument is the optional string to be placed in the certificate
# subjectAlternativeName field.  When provided, we use a special CA section
# in the openssl.conf file that will include the list in the generated
# certificate.  When absent, we use a different CA section without the
# extension.  We have to define something in both cases since openssl will
# throw an error trying to read an empty environment variable even for
# config sections that aren't actually used.
if [ ! -z "$3" -a "$3" != "" ]; then
    UT_ROOT_MODE="CA_sanlist"
    UT_SAN_LIST="$3"
else
    UT_ROOT_MODE="CA_onehost"
    UT_SAN_LIST="empty"
fi

# export all environment variables referenced in our openssl config file
export UT_ROOT_PATH
export UT_ROOT_MODE
export UT_SAN_LIST
export RANDFILE

# if either of the root certificate files are missing we bail
if [ ! -r $UT_ROOT_PATH/untangle.key -o ! -r $UT_ROOT_PATH/untangle.crt ]; then
    echo "Unable to locate the root certificate authority files"
    exit 3
fi

# make sure the destination path for certificates exists
if [ ! -r $CERT_PATH ]; then
    mkdir -p $CERT_PATH
fi

SERIAL=`cat $UT_ROOT_PATH/serial.txt`

case $1 in
    REQUEST)
    # Here we generate a new CSR for this server to be signed by a third party
    # using the existing private key file that was previously created
    # when the original Apache server certificate was generated
        $OPENSSL_TOOL req -batch -nodes -config $OPENSSL_CONF -new -key $UT_ROOT_PATH/apache.key -out $UT_ROOT_PATH/apache.csr -subj "$2"
    ;;
    APACHE)
    # When making the Apache server certificate we generate a new CSR and
    # sign it with our CA.  We hang onto the original separate KEY and CRT
    # files so the private key can later be used if they decide to
    # generate a CSR for this server, and we also combine them to make
    # the PEM file that we copy into the Apache directory
        $OPENSSL_TOOL req -batch -nodes -config $OPENSSL_CONF -newkey rsa:2048 -keyout $UT_ROOT_PATH/apache.key -out $UT_ROOT_PATH/apache.csr -subj "$2"
        $OPENSSL_TOOL ca -batch -config $OPENSSL_CONF -policy policy_anything -startdate 100102030405Z -enddate 380102030405Z -out $TEMP/server.crt -outdir $TEMP -infiles $UT_ROOT_PATH/apache.csr
        grep -A 1000 BEGIN $TEMP/server.crt > $UT_ROOT_PATH/apache.crt
        cat $UT_ROOT_PATH/apache.key $UT_ROOT_PATH/apache.crt > $UT_ROOT_PATH/apache.pem
    ;;
    *)
    # In all other cases we are making a fake MITM certificate so we generate
    # a new CSR and sign it with our CA and put the server key and signed
    # cert into a PKCS12 file that can be loaded by the Java code
        $OPENSSL_TOOL req -batch -nodes -config $OPENSSL_CONF -newkey rsa:2048 -keyout $TEMP/server.key -out $TEMP/server.csr -subj "$2"
        $OPENSSL_TOOL ca -batch -config $OPENSSL_CONF -policy policy_anything -startdate 100102030405Z -enddate 380102030405Z -out $TEMP/server.crt -outdir $TEMP -infiles $TEMP/server.csr
        $OPENSSL_TOOL pkcs12 -passout pass:password -export -name default -in $TEMP/server.crt -inkey $TEMP/server.key -out "$CERT_PATH/$1"
    ;;
esac

# Cleanup any working files we created
rm -f $TEMP/server.key
rm -f $TEMP/server.csr
rm -f $TEMP/server.crt
rm -f $TEMP/$SERIAL.pem

