/*
 * Copyright (c) 2003-2007 Untangle, Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Untangle, Inc. ("Confidential Information"). You shall
 * not disclose such Confidential Information.
 *
 * $Id$
 */

package com.untangle.mvvm.networking;

import java.io.File;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.BufferedWriter;

import java.util.List;

import org.apache.log4j.Logger;

import com.untangle.jnetcap.Netcap;
import com.untangle.jnetcap.JNetcapException;
import com.untangle.jnetcap.PortRange;

import com.untangle.mvvm.ArgonException;
import com.untangle.mvvm.IntfConstants;
import com.untangle.mvvm.MvvmContextFactory;
import com.untangle.mvvm.localapi.ArgonInterface;
import com.untangle.mvvm.localapi.LocalIntfManager;

import com.untangle.mvvm.tran.IPaddr;
import com.untangle.mvvm.tran.TransformException;
import com.untangle.mvvm.tran.script.ScriptRunner;

import com.untangle.mvvm.networking.internal.InterfaceInternal;
import com.untangle.mvvm.networking.internal.NetworkSpaceInternal;

public class RuleManager
{
    private static final String HEADER = "##AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n\n";

    private static final String UDP_DIVERT_PORT_FLAG         = "UDP_DIVERT_PORT";
    private static final String TCP_REDIRECT_PORT_FLAG       = "TCP_REDIRECT_PORTS";
    private static final String ANTISUBSCRIBE_LOCAL_IN_FLAG  = "ANTISUBSCRIBE_LOCAL_INSIDE";
    private static final String ANTISUBSCRIBE_LOCAL_OUT_FLAG = "ANTISUBSCRIBE_LOCAL_OUTSIDE";
    private static final String DHCP_BLOCK_FORWARD_FLAG      = "DHCP_BLOCK_FORWARDING";
    private static final String PUBLIC_ADDR_FLAG             = "HTTPS_PUBLIC_ADDR";
    private static final String PUBLIC_PORT_FLAG             = "HTTPS_PUBLIC_PORT";
    private static final String PUBLIC_REDIRECT_EN           = "HTTPS_PUBLIC_REDIRECT_EN";
    /* Flags to set the redirect for traffic to the internal admin port */
    private static final String INTERNAL_OPEN_REDIRECT_FLAG  = "HTTPS_INTERNAL_REDIRECT_PORT";
    

    /* Flags to use to steal an address and a few ports */
    private static final String SETUP_MODE_FLAG              = "IS_IN_SETUP_MODE";
    private static final String SETUP_ADDRESS_FLAG           = "STEAL_ADDRESS";
    private static final String SETUP_INTERFACE_FLAG         = "STEAL_INTERFACE";
    private static final String SETUP_TCP_PORTS_FLAG         = "STEAL_TCP_PORTS";
    private static final String SETUP_UDP_PORTS_FLAG         = "STEAL_UDP_PORTS";

    /* Set to a list of interfaces that are in the services space that need to be able to
     * access the services */
    private static final String SERVICES_INTERFACE_LIST      = "MVVM_SERVICES_INTF_LIST";

    /* Set to the index of the interfaces where ping should be enabled. */
    private static final String PING_ANTISUBSCRIBE_FLAG      = "MVVM_PING_EN";
    private static final String PING_ANTISUBSCRIBE_LIST      = "MVVM_PING_LIST";

    private static RuleManager INSTANCE = null;

    private final String BUNNICULA_BASE = System.getProperty( "bunnicula.home" );
    private final String BUNNICULA_CONF = System.getProperty( "bunnicula.conf.dir" );
    private final String MVVM_TMP_FILE  = BUNNICULA_CONF + "/tmp_params";

    private final String RULE_GENERATOR_SCRIPT = BUNNICULA_BASE + "/networking/rule-generator";
    private final String RULE_DESTROYER_SCRIPT = BUNNICULA_BASE + "/networking/rule-destroyer";

    private final Logger logger = Logger.getLogger( RuleManager.class );

    private boolean subscribeLocalInside  = true;
    private boolean subscribeLocalOutside = true;
    private boolean dhcpEnableForwarding  = true;

    private boolean isPublicRedirectEnabled = false;

    private IPaddr publicAddress = null;
    private int publicPort = -1;

    private boolean isShutdown = false;

    /* Set to true in order to use the value specified in the interface list */
    private boolean pingInterfaceEnable = false;

    /* List of the interfaces where ping is enabled */
    private String pingInterfaceList = "";

    /* List of interfaces that are in the services spaces */
    private String servicesInterfaceList = "";

    /* True if setup has been completed */
    private boolean hasCompletedSetup = true;

    /* Call the script to generate all of the iptables rules */
    synchronized void generateIptablesRules() throws NetworkException
    {
        if ( isShutdown ) {
            logger.warn( "MVVM is already shutting down, no longer able to generate rules" );
            return;
        }

        try {
            writeConfig();

            ScriptRunner.getInstance().exec( RULE_GENERATOR_SCRIPT );
        } catch ( Exception e ) {
            logger.error( "Error while generating iptables rules", e );
            throw new NetworkException( "Unable to generate iptables rules", e );
        }        
    }

    synchronized void destroyIptablesRules() throws NetworkException
    {
        try {
            /* Call the rule generator */
            ScriptRunner.getInstance().exec( RULE_DESTROYER_SCRIPT );            
        } catch ( Exception e ) {
            logger.error( "Error while removing iptables rules", e );
            throw new NetworkException( "Unable to remove iptables rules", e );
        }        
    }

    void subscribeLocalInside( boolean subscribeLocalInside )
    {
        this.subscribeLocalInside = subscribeLocalInside;
    }

    void subscribeLocalOutside( boolean subscribeLocalOutside )
    {
        this.subscribeLocalOutside = subscribeLocalOutside;
    }
    
    void dhcpEnableForwarding( boolean dhcpEnableForwarding )
    {
        this.dhcpEnableForwarding = dhcpEnableForwarding;
    }

    void setPublicAddress( IPaddr publicAddress, int port, boolean isPublicRedirectEnabled  )
    {
        this.publicAddress = publicAddress;
        this.publicPort    = port;
        this.isPublicRedirectEnabled = isPublicRedirectEnabled;
    }

    /* Just used to setup the antisubscribes */
    void setInterfaceList( List<InterfaceInternal> interfaceList, NetworkSpaceInternal serviceSpace )
    {
        String pingAntisubscribeList = "";
        
        String servicesInterfaceList = "";
        
        LocalIntfManager lim = MvvmContextFactory.context().localIntfManager();

        for ( InterfaceInternal intf : interfaceList ) {
            ArgonInterface argonIntf = intf.getArgonIntf();
            if ( serviceSpace != null && serviceSpace.equals( intf.getNetworkSpace())) {
                switch( argonIntf.getArgon()) {
                case IntfConstants.EXTERNAL_INTF:
                    /* Always ignore the external interface */
                    break;
                    
                case IntfConstants.DMZ_INTF:
                    /* DMZ interface is not added if it is in the public space */
                    if ( 0 == serviceSpace.getIndex()) break;
                    
                    /* fallthrough */
                default:
                    /* All other interfaces are always added unconditionally */
                    servicesInterfaceList += " " + argonIntf.getName();
                }
            }
            
            if ( intf.isPingable()) {
                pingAntisubscribeList = pingAntisubscribeList + " " + argonIntf.getNetcap();
            }
        }
        
        this.pingInterfaceEnable = true;
        this.pingInterfaceList   = pingAntisubscribeList.trim();
        this.servicesInterfaceList = servicesInterfaceList.trim();
    }

    void setHasCompletedSetup( boolean newValue )
    {
        this.hasCompletedSetup = newValue;
    }

    synchronized void isShutdown()
    {
        this.isShutdown = true;
    }

    private void writeConfig() throws NetworkException
    {
        try {
            StringBuilder sb = new StringBuilder();
            
            Netcap netcap = Netcap.getInstance();
            
            sb.append( HEADER );
            
            PortRange tcp = netcap.tcpRedirectPortRange();
            int divertPort = netcap.udpDivertPort();
            
            sb.append( TCP_REDIRECT_PORT_FLAG       + "=" + tcp.low() + ":" + tcp.high() + "\n" );
            sb.append( UDP_DIVERT_PORT_FLAG         + "=" + divertPort + "\n" );
            sb.append( ANTISUBSCRIBE_LOCAL_IN_FLAG  + "=" + !subscribeLocalInside + "\n" );
            sb.append( ANTISUBSCRIBE_LOCAL_OUT_FLAG + "=" + !subscribeLocalOutside + "\n" );
            if ( publicAddress != null && publicPort > 0 ) {
                sb.append( PUBLIC_ADDR_FLAG         + "=" + publicAddress + "\n" );
                sb.append( PUBLIC_PORT_FLAG         + "=" + publicPort + "\n" );
                if ( isPublicRedirectEnabled ) {
                    sb.append( PUBLIC_REDIRECT_EN + "=true\n" );
                }
            }

            sb.append( DHCP_BLOCK_FORWARD_FLAG      + "=" + !dhcpEnableForwarding  + "\n\n" );

            if ( pingInterfaceEnable ) {
                sb.append( PING_ANTISUBSCRIBE_FLAG    + "=true\n"  );
                sb.append( PING_ANTISUBSCRIBE_LIST    + "=\"" + this.pingInterfaceList + "\"\n" );
            }

            if (( null != this.servicesInterfaceList ) && ( this.servicesInterfaceList.length() > 0 )) {
                sb.append( SERVICES_INTERFACE_LIST + "=\"" + this.servicesInterfaceList + "\"\n" );
            }

            LocalIntfManager lim = MvvmContextFactory.context().localIntfManager();
            
            /* Setup a rule for stealing ARPs */
            if ( !this.hasCompletedSetup ) {
                String internal = "eth1";
                
                internal = lim.getInternal().getName();

                sb.append( SETUP_MODE_FLAG + "=true\n" );
                sb.append( SETUP_ADDRESS_FLAG + "=" + NetworkUtil.SETUP_ADDRESS + "\n" );
                sb.append( SETUP_INTERFACE_FLAG + "=" + internal + "\n" );
                /* Steal ports 80 and 443 for HTTP and HTTPs */
                sb.append( SETUP_TCP_PORTS_FLAG + "=80,443\n" );

                /* Steal port 53 for DHCP */
                sb.append( SETUP_UDP_PORTS_FLAG + "=53\n" );
            }

            /* Setup all of the values for the interfaces */
            /* XXX When we want to use custom interfaces we should just redefine INTERFACE_ORDER */
            for ( ArgonInterface intf : lim.getIntfList()) {
                if ( intf.hasSecondaryName()) {
                    String argonName = IntfConstants.toName( intf.getArgon()).toUpperCase();
                    sb.append( "MVVM_" + argonName + "_INTF=" + intf.getSecondaryName() + "\n" );
                }
            }

            /* Add the flag to redirect traffic from 443, to the special internal open port */
            sb.append( INTERNAL_OPEN_REDIRECT_FLAG + "=" + NetworkUtil.INTERNAL_OPEN_HTTPS_PORT +"\n" );
            
            writeFile( sb, MVVM_TMP_FILE );
        } catch ( JNetcapException e ) {
            logger.error( "Unable to write rule manager configuration", e );
        }
    }

    private void writeFile( StringBuilder sb, String fileName ) throws NetworkException
    {
        BufferedWriter out = null;
        
        /* Open up the interfaces file */
        try {
            String data = sb.toString();
            
            out = new BufferedWriter(new FileWriter( fileName ));
            out.write( data, 0, data.length());
        } catch ( Exception ex ) {
            /* XXX May need to catch this exception, restore defaults
             * then try again */
            logger.error( "Error writing file " + fileName + ":", ex );
            throw new NetworkException( "Error writing file " + fileName, ex );
        } finally {
            try {
                if ( out != null ) out.close();
            } catch ( Exception e ) {
                logger.error( "Unable to close file", e );
            }
        }
    }

    static synchronized RuleManager getInstance()
    {
        if ( INSTANCE == null ) {
            INSTANCE = new RuleManager();
        }
        
        return INSTANCE;
    }
}
