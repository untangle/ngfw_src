/*
 * Copyright (c) 2003-2007 Untangle, Inc.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Untangle, Inc. ("Confidential Information"). You shall
 * not disclose such Confidential Information.
 *
 * $Id$
 */

package com.untangle.mvvm.networking;

import java.io.BufferedReader;
import java.io.FileReader;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.untangle.jnetcap.InterfaceData;
import com.untangle.jnetcap.Netcap;
import com.untangle.mvvm.ArgonException;
import com.untangle.mvvm.InterfaceAlias;
import com.untangle.mvvm.IntfConstants;
import com.untangle.mvvm.MvvmContextFactory;
import com.untangle.mvvm.localapi.LocalIntfManager;
import com.untangle.mvvm.networking.internal.InterfaceInternal;
import com.untangle.mvvm.networking.internal.NetworkSpaceInternal;
import com.untangle.mvvm.networking.internal.NetworkSpacesInternalSettings;
import com.untangle.mvvm.networking.internal.RedirectInternal;
import com.untangle.mvvm.networking.internal.RouteInternal;
import com.untangle.mvvm.networking.internal.ServicesInternalSettings;
import com.untangle.mvvm.tran.HostName;
import com.untangle.mvvm.tran.IPaddr;
import com.untangle.mvvm.tran.ValidateException;
import com.untangle.mvvm.util.ConfigFileUtil;
import org.apache.log4j.Logger;

/* Utilities that are only required inside of this package */
class NetworkUtilPriv extends NetworkUtil
{
    private final Logger logger = Logger.getLogger(getClass());

    private static final NetworkUtilPriv INSTANCE = new NetworkUtilPriv();

    private static final String HOST_NAME_FILE        = "/etc/hostname";

    private static final int DDCLIENT_UPDATE_INTERVAL = 300; // Seconds (5 minutes)
    private static final String DDCLIENT_CMD          = "/etc/init.d/ddclient ";
    private static final String DDCLIENT_CMD_STOP  = DDCLIENT_CMD + " stop";
    private static final String DDCLIENT_CMD_RESTART  = DDCLIENT_CMD + " restart";
    private static final String DDCLIENT_CONF_FILE    = "/etc/ddclient.conf";
    private static final String DDCLIENT_DEFAULT_FILE    = "/etc/default/ddclient";

    private static final String DDCLIENT_CONF_START =
        "# AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n\n" +
        "pid=/var/run/ddclient.pid\n" +
        "use=if, if=";

    private static final String DDCLIENT_DEFAULT_START =
        "# AUTOGENERATED BY METAVIZE DO NOT MODIFY MANUALLY\n\n" +
        "run_ipup=\"false\"\n" +
        "daemon_interval=\"" + DDCLIENT_UPDATE_INTERVAL + "\"\n";

    /* Prefix for the bridge devices */
    private static final String BRIDGE_PREFIX  = "br";

    /* Index of the first network space */
    public static final int SPACE_INDEX_BASE = 0;

    /* Size of an ip addr byte array */
    public static final int IP_ADDR_SIZE_BYTES = 4;

    private NetworkUtilPriv()
    {
    }

    /* Convert a NetworkConfiguration and the previous internal network settings into
     * a new network spaces settings object.
     * @param networkingConfiguration:  New networking configuration for the primary space.
     * @param internalSettings: Current configuration for all of the other spaces.
     */
    public NetworkSpacesInternalSettings toInternal( BasicNetworkSettings basic,
                                                     NetworkSpacesInternalSettings internalSettings,
                                                     boolean hasCompletedSetup )
        throws NetworkException, ValidateException
    {
        NetworkSpacesSettings settings = toSettings( internalSettings );

        settings.setHasCompletedSetup( hasCompletedSetup );

        /* Now replace the parameters for the first space */
        NetworkSpace primary = settings.getNetworkSpaceList().get( 0 );

        boolean isDhcpEnabled = basic.isDhcpEnabled();
        primary.setIsDhcpEnabled( basic.isDhcpEnabled());
        primary.setIsNatEnabled( false );
        primary.setNatSpace( null );
        primary.setNatAddress( null );
        primary.setIsDmzHostEnabled( false );
        primary.setIsDmzHostLoggingEnabled( false );
        primary.setDmzHost( null );
        List<IPNetworkRule> networkList = new LinkedList<IPNetworkRule>();

        if ( !isDhcpEnabled ) networkList.add( IPNetworkRule.makeInstance( basic.host(), basic.netmask()));

        /* Add all of the other networks from the alias list */
        for ( InterfaceAlias a : basic.getAliasList()) {
            networkList.add( IPNetworkRule.makeInstance( a.getAddress(), a.getNetmask()));
        }

        /* Set the network list */
        primary.setNetworkList( networkList );

        settings.setDefaultRoute( basic.gateway());
        settings.setDns1( basic.dns1());
        settings.setDns2( basic.dns2());

        return toInternal( settings );
    }

    /** this function is a mess on almost every level */
    public NetworkSpacesInternalSettings toInternal( NetworkSpacesSettings networkSettings )
        throws NetworkException, ValidateException
    {
        List<InterfaceInternal> interfaceList       = new LinkedList<InterfaceInternal>();
        List<NetworkSpaceInternal> networkSpaceList = new LinkedList<NetworkSpaceInternal>();
        List<RouteInternal> routingTable            = new LinkedList<RouteInternal>();

        /* This must be ordered, or else the network spaces come out, out of order */
        Map<NetworkSpace,SpaceInfo> spaceToInfoMap = new LinkedHashMap<NetworkSpace,SpaceInfo>();

        /* First pass, get all of the primary addresses and interface lists */
        List<Interface> intfListCopy = new LinkedList<Interface>( networkSettings.getInterfaceList());

        /* Boolean to indicate whether or not the user has completed setup */
        boolean hasCompletedSetup = networkSettings.getHasCompletedSetup();

        LocalIntfManager lim = MvvmContextFactory.context().localIntfManager();

        int index = SPACE_INDEX_BASE;

        SpaceInfo primarySpaceInfo = null;
        for ( NetworkSpace networkSpace : networkSettings.getNetworkSpaceList()) {
            Interface primaryIntf = null;
            List<Interface> networkSpaceIntfList = new LinkedList<Interface>();

            String deviceName = BRIDGE_PREFIX + index;

            if ( networkSpace.isLive()) {

                logger.debug( "network space: " + networkSpace.hashCode() + " " +
                              networkSpace.getBusinessPapers());

                /* Use an iterator in order to allow for remove */
                for ( Iterator<Interface> iter = intfListCopy.iterator() ; iter.hasNext() ; ) {
                    Interface intf = iter.next();

                    NetworkSpace intfSpace = intf.getNetworkSpace();
                    logger.debug( "Interface: " + intf.getArgonIntf() + " / " +
                                  intfSpace.getName() + " " + intfSpace.hashCode()
                                  + " " + intfSpace.getBusinessPapers());

                    if ( intfSpace.equals( networkSpace ) ||
                         ( intfSpace.getBusinessPapers() == networkSpace.getBusinessPapers())) {
                        /* If there are more than 1, it is a bridge anyway, so the primary interface
                         * doesn't matter */
                        primaryIntf = intf;
                        iter.remove();

                        networkSpaceIntfList.add( intf );
                    }
                }

                switch ( networkSpaceIntfList.size()) {
                case 0:
                    throw new NetworkException( "Each enabled network space " + index +
                                                " must be mapped to an interface" );
                case 1:
                    try {
                        /* XXXX Does the device name mean the phyiscal interface or the virtual
                         * interface */
                        deviceName = lim.argonIntfToString( primaryIntf.getArgonIntf());
                    } catch ( ArgonException e ) {
                        throw new NetworkException( "Invalid argonInterface: " + primaryIntf.getArgonIntf());
                    }
                    break;
                default:
                    /* Nothing to do */
                }
            }

            IPNetwork primaryAddress = getPrimaryAddress( networkSpace, index );

            SpaceInfo info = new SpaceInfo( networkSpace, deviceName, index,
                                            networkSpaceIntfList, primaryAddress );
            spaceToInfoMap.put( networkSpace, info );
            if ( index == SPACE_INDEX_BASE ) primarySpaceInfo = info;
            index++;
        }

        if ( intfListCopy.size() > 0 ) {
            throw new NetworkException( "At least one interface [ " + intfListCopy +" ] was not" +
                                        " bound to a network space." );
        }

        /** Set the NAT addresses on the second iteration, this is when the primary
         * address has been set on all of the spaces. */
        for ( SpaceInfo info :  spaceToInfoMap.values()) {
            try {
                setNatAddress( info, spaceToInfoMap );
            } catch ( NetworkException e ) {
                /* This is kind of dirty, but it is better than network configuration failing */
                logger.error( "unable to set the nat address on a space, disabling NAT.", e );
                NetworkSpace space = info.getNetworkSpace();
                if ( space != null ) {
                    space.setIsNatEnabled( false);
                }
            }

            NetworkSpaceInternal nwi;
            if ( !hasCompletedSetup && info.getIndex() == 1 ) {
                /* Make the setup space as a bridge */
                nwi = NetworkSpaceInternal.
                    makeInstance( info.getNetworkSpace(), info.getInterfaceList(), info.getPrimaryAddress(),
                                  BRIDGE_PREFIX + 1, info.getIndex(), info.getNatAddress(),
                                  info.getNatSpaceIndex(), true );
            } else {
                nwi = makeNetworkSpaceInternal( info );
            }

            /* Iterate all of its interfaces and add them to the
             *  interface list, this allows the network space in the
             *  interface to be final and to also have a final mapping
             *  between the network space and the interface.  */
            for ( InterfaceInternal intf : nwi.getInterfaceList()) interfaceList.add( intf );

            /* Add the network space to the list of network spaces. */
            networkSpaceList.add( nwi );
        }

        /* Create all of the routing entries */
        for ( Route route : networkSettings.getRoutingTable()) {
            routingTable.add( RouteInternal.makeInstance( route ));
        }

        /* Thsese may come from DHCP */
        IPaddr dns1          = networkSettings.getDns1();
        IPaddr dns2          = networkSettings.getDns2();

        IPaddr defaultRoute  = networkSettings.getDefaultRoute();

        SetupState setupState = networkSettings.getSetupState();
        boolean isEnabled     = networkSettings.getIsEnabled();

        /* Create all of the redirects */
        List<RedirectInternal> redirectList = new LinkedList<RedirectInternal>();

        int redirectIndex = 1;
        for ( RedirectRule redirect : networkSettings.getRedirectList()) {
            redirectList.add( new RedirectInternal( redirect, redirectIndex++ ));
        }


        /* If necessary, move all of the interfaces into the primary network space */
        List<InterfaceInternal> realInterfaceList = interfaceList;
        if ( !isEnabled ) {
            realInterfaceList = new LinkedList<InterfaceInternal>();
            SpaceInfo i = primarySpaceInfo;
            SpaceInfo info = new SpaceInfo( i.getNetworkSpace(), BRIDGE_PREFIX + SPACE_INDEX_BASE,
                                            SPACE_INDEX_BASE, networkSettings.getInterfaceList(),
                                            i.getPrimaryAddress());
            info.setNatAddress( null );

            NetworkSpaceInternal nwi = makeNetworkSpaceInternal( info );

            /* Create a list of all of the interfaces mapped to the first space */
            for ( InterfaceInternal intf : nwi.getInterfaceList()) realInterfaceList.add( intf );

            /* Replace the first space with the new one the network space to the list of network spaces. */
            networkSpaceList.remove( 0 );
            networkSpaceList.add( 0, nwi );
        }

        return NetworkSpacesInternalSettings.
            makeInstance( setupState, isEnabled, hasCompletedSetup,
                          realInterfaceList, interfaceList, networkSpaceList,
                          routingTable, redirectList, dns1, dns2, defaultRoute );

    }

    BasicNetworkSettings toBasic( NetworkSpacesInternalSettings settings )
    {
        BasicNetworkSettings basic = new BasicNetworkSettings();

        NetworkSpaceInternal primary = settings.getNetworkSpaceList().get( 0 );
        
        basic.isDhcpEnabled( primary.getIsDhcpEnabled());
        IPNetwork primaryNetwork = primary.getPrimaryAddress();

        basic.host( primaryNetwork.getNetwork());
        basic.netmask( primaryNetwork.getNetmask());

        /* interface aliases */
        List<InterfaceAlias> aliasList = new LinkedList<InterfaceAlias>();
        for ( IPNetwork network : primary.getNetworkList()) {
            if ( network.equals( primaryNetwork )) continue;
            aliasList.add( new InterfaceAlias( network.getNetwork(), network.getNetmask()));
        }
        basic.setAliasList( aliasList );
        
        basic.dns1( settings.getDns1());
        basic.dns2( settings.getDns2());
        basic.gateway( settings.getDefaultRoute());

        logger.debug( "created: " + basic );

        /* XXXXXXXX PPPOE XXXXXXX */
        return basic;
    }
    
    /**
     * Convert a networking configuration object to an internal representation.
     * This should only be used when updating a box.  Under other circumstances,
     * the other converter which takes the networking configuration and the previous
     * internal settings should be used
     */
    NetworkSpacesInternalSettings toInternal( BasicNetworkSettings basic )
        throws NetworkException, ValidateException
    {
        LocalIntfManager lim = MvvmContextFactory.context().localIntfManager();

        NetworkSpacesSettings newSettings = new NetworkSpacesSettingsImpl();

        /* By default the network space settings are disabled */
        newSettings.setIsEnabled( false );

        /* Build an empty network settings where all of the interfaces are mapped to the
         * first network space */

        /* Create a single network space */
        NetworkSpace primary = new NetworkSpace();
        primary.setName( NetworkUtil.DEFAULT_SPACE_NAME_PRIMARY );

        primary.setBusinessPapers( 0 );
        primary.setIsTrafficForwarded( true );
        primary.setIsNatEnabled( false );
        primary.setIsDmzHostEnabled( false );
        primary.setIsDhcpEnabled( basic.isDhcpEnabled());

        List<Interface> interfaceList = new LinkedList<Interface>();

        byte [] argonIntfArray = getArgonIntfArray();
        for ( byte argonIntf : argonIntfArray ) {
            /* The VPN interface doesn't belong to a network space */
            if ( argonIntf == IntfConstants.VPN_INTF ) continue;

            /* Add each interface to the list */
            Interface intf =  new Interface( argonIntf, EthernetMedia.AUTO_NEGOTIATE, true );
            intf.setName( IntfConstants.toName( argonIntf ));
            intf.setNetworkSpace( primary );
            interfaceList.add( intf );
        }
        List<NetworkSpace> networkSpaceList = new LinkedList<NetworkSpace>();

        /* Set the address and the address of the aliases */
        List<IPNetworkRule> networkList = new LinkedList<IPNetworkRule>();

        IPaddr host = basic.host();
        IPaddr netmask = basic.netmask();
        if (( host == null ) || ( netmask == null ) || ( host.isEmpty()) || netmask.isEmpty()) {
            /* This is pretty bad */
            logger.warn( "Configuration has an empty address[" + host + "] is netmask [" + netmask + "]" );
        } else {
            /* Only add this address if DHCP is not enabled */
            if ( !basic.isDhcpEnabled()) {
                networkList.add( IPNetworkRule.makeInstance( host, netmask ));
            }
        }

        for ( InterfaceAlias alias : basic.getAliasList()) {
            host = alias.getAddress();
            netmask = alias.getNetmask();
            if (( host == null ) || ( netmask == null ) || ( host.isEmpty()) || netmask.isEmpty()) {
                /* This is pretty bad */
                logger.warn( "Configuration has an empty address[" + host + "] is netmask [" +
                             netmask + "]" );
            } else {
                networkList.add( IPNetworkRule.makeInstance( host, netmask ));
            }
        }

        primary.setNetworkList( networkList );

        networkSpaceList.add( primary );

        newSettings.setInterfaceList( interfaceList );
        newSettings.setNetworkSpaceList( networkSpaceList );
        newSettings.setRoutingTable( new LinkedList<Route>());
        newSettings.setDefaultRoute( basic.gateway());
        newSettings.setDns1( basic.dns1());
        newSettings.setDns2( basic.dns2());

        return toInternal( newSettings );
    }

    ServicesInternalSettings toInternal( NetworkSpacesInternalSettings settings, DhcpServerSettings dhcp,
                                         DnsServerSettings dns )
    {
        NetworkSpaceInternal serviceSpace = settings.getServiceSpace();

        boolean isEnabled = settings.getIsEnabled();

        IPaddr defaultRoute;
        IPaddr netmask;
        List<IPaddr> dnsServerList = new LinkedList<IPaddr>();
        String interfaceName =  null;
        IPNetwork primary = serviceSpace.getPrimaryAddress();

        if ( serviceSpace.getIsNatEnabled()) {
            defaultRoute = primary.getNetwork();
            netmask = primary.getNetmask();
            /* Only add the default route if dns is enabled */
            if ( isEnabled && dns.getDnsEnabled() ) {
                dnsServerList.add( defaultRoute );
            } else {
                /* Otherwise, dhcp would serve the addresses the box uses for DNS */
                if ( !settings.getDns1().isEmpty()) dnsServerList.add( settings.getDns1());
                if ( !settings.getDns2().isEmpty()) dnsServerList.add( settings.getDns2());
            }
            interfaceName = serviceSpace.getDeviceName();
        } else {
            /* This might be incorrect to assume the default route of the box */
            defaultRoute = settings.getDefaultRoute();
            netmask = primary.getNetmask();
            if ( isEnabled && dns.getDnsEnabled()) {
                dnsServerList.add( primary.getNetwork());
            } else {
                if ( !settings.getDns1().isEmpty()) dnsServerList.add( settings.getDns1());
                if ( !settings.getDns2().isEmpty()) dnsServerList.add( settings.getDns2());
            }


            /* Don't bind to an interface */
            interfaceName = null;
        }

        return ServicesInternalSettings.
            makeInstance( isEnabled, dhcp, dns, defaultRoute, netmask, dnsServerList,
                          interfaceName, primary.getNetwork());
    }

    /** Used when update address is called.  This only updates the dhcp address */
    NetworkSpacesInternalSettings updateDhcpAddresses( NetworkSpacesInternalSettings internal )
        throws NetworkException, ValidateException
    {
        /* Convert the settings out */
        NetworkSpacesSettings settings = toSettings( internal );

        /* XXXX DHCP only works on the first space. */
        /* This assumes at least one space */
        NetworkSpace space = settings.getNetworkSpaceList().get( 0 );

        Netcap netcap = Netcap.getInstance();

        DhcpStatus status =
            new DhcpStatus( NetworkUtil.BOGUS_DHCP_ADDRESS, NetworkUtil.BOGUS_DHCP_NETMASK );

        try {
            LocalIntfManager lim = MvvmContextFactory.context().localIntfManager();

            /* XXX Right now the only space that supports DHCP is the external space,
             * need to update for when there are others */
            String external = lim.getExternal().getName();
            List<InterfaceData> externalIntfDataList = netcap.getInterfaceData( external );

            if ( externalIntfDataList == null || ( externalIntfDataList.size() == 0 )) {
                throw new Exception( "no interface data for external interface." );
            }

            InterfaceData data = externalIntfDataList.get( 0 );
            status = new DhcpStatus( data.getAddress(), data.getNetmask());

            /* RBS: Changing this function scares me, but it has to be done */
            if ( space.getIsDhcpEnabled()) {
                /* Update the dns servers */
                List<IPaddr> dnsServers = getDnsServers();

                switch( dnsServers.size()) {
                default:
                case 2:
                    settings.setDns2( dnsServers.get( 1 ));

                    /* fallthrough */
                case 1:
                    settings.setDns1( dnsServers.get( 0 ));
                    break;

                case 0:
                    logger.info( "DHCP didn't set any DNS servers" );
                }

                /* Update the default route */
                Inet4Address gateway = (Inet4Address)Netcap.getGateway();
                if ( gateway == null ) settings.setDefaultRoute( NetworkUtil.EMPTY_IPADDR );
                else                   settings.setDefaultRoute( new IPaddr( gateway ));
            }
        } catch( Exception e ) {
            logger.warn( "Error updating DHCP address", e );
        }

        logger.debug( "Updating the primary address for the space '" + space.getName() + "'" );
        logger.debug( status );

        space.setDhcpStatus( status );

        return toInternal( settings );
    }

    /* Get the default settings for services */
    ServicesSettingsImpl getDefaultServicesSettings()
    {
        ServicesSettingsImpl services = new ServicesSettingsImpl();

        services.setDhcpEnabled( false );
        services.setDhcpStartAddress( NetworkUtil.DEFAULT_DHCP_START );
        services.setDhcpEndAddress( NetworkUtil.DEFAULT_DHCP_END );
        services.setDhcpLeaseTime( NetworkUtil.DEFAULT_LEASE_TIME_SEC );

        services.setDnsEnabled( false );
        return services;

    }

    /* Used when the network settings change, but the dns masq settings haven't */
    ServicesInternalSettings update( NetworkSpacesInternalSettings settings,
                                     ServicesInternalSettings services )
    {
        NetworkSpaceInternal serviceSpace = settings.getServiceSpace();

        IPaddr defaultRoute;
        IPaddr netmask;
        List<IPaddr> dnsServerList = new LinkedList<IPaddr>();
        String interfaceName =  null;

        boolean isEnabled = settings.getIsEnabled();

        IPNetwork primary = serviceSpace.getPrimaryAddress();

        /* XXX Code is duplicated with toInternal XXX */
        if ( serviceSpace.getIsNatEnabled()) {
            defaultRoute = primary.getNetwork();
            netmask = primary.getNetmask();
            /* Only add the default route if dns is enabled */
            if ( isEnabled && services.getIsDnsEnabled() ) {
                dnsServerList.add( defaultRoute );
            } else {
                /* Otherwise, dhcp would serve the addresses the box uses for DNS */
                if ( !settings.getDns1().isEmpty()) dnsServerList.add( settings.getDns1());
                if ( !settings.getDns2().isEmpty()) dnsServerList.add( settings.getDns2());
            }
            interfaceName = serviceSpace.getDeviceName();
        } else {
            /* This might be incorrect to assume the default route of the box */
            defaultRoute = settings.getDefaultRoute();
            netmask = primary.getNetmask();
            if ( isEnabled && services.getIsDnsEnabled()) {
                dnsServerList.add( primary.getNetwork());
            } else {
                if ( !settings.getDns1().isEmpty()) dnsServerList.add( settings.getDns1());
                if ( !settings.getDns2().isEmpty()) dnsServerList.add( settings.getDns2());
            }


            /* Don't bind to an interface */
            interfaceName = null;
        }

        return ServicesInternalSettings.
            makeInstance( settings.getIsEnabled(), services, defaultRoute, netmask, dnsServerList,
                          interfaceName, primary.getNetwork());

    }

    /* Return the impl so this can go into a database */
    NetworkSpacesSettingsImpl toSettings( NetworkSpacesInternalSettings internalSettings )
    {
        NetworkSpacesSettingsImpl settings = new NetworkSpacesSettingsImpl();

        settings.setSetupState( internalSettings.getSetupState());

        /* Generate the list network spaces and a map from internal -> normal. */
        List<NetworkSpace> networkSpaceList = new LinkedList<NetworkSpace>();

        settings.setIsEnabled( internalSettings.getIsEnabled());

        Map<NetworkSpaceInternal,NetworkSpace> networkSpaceMap =
            new HashMap<NetworkSpaceInternal,NetworkSpace>();

        NetworkSpace primary = null;

        for ( NetworkSpaceInternal si : internalSettings.getNetworkSpaceList()) {
            NetworkSpace space = si.toNetworkSpace();

            if ( primary == null ) primary = space;

            /* Placed into both in order to maintain the order of the items */
            networkSpaceMap.put( si, space );
            networkSpaceList.add( space );
            space.setIsPrimary( false );
        }

        /* Assuming there is at least one space, otherwise primary would be null. */
        primary.setIsPrimary( true );

        /* Update the nat space in the ones where this is needed. */
        for ( Map.Entry<NetworkSpaceInternal,NetworkSpace> entry : networkSpaceMap.entrySet()) {
            NetworkSpace space = entry.getValue();
            NetworkSpaceInternal si = entry.getKey();

            int natSpaceIndex = si.getNatSpaceIndex();

            if ( natSpaceIndex >= 0 && ( natSpaceIndex <= networkSpaceList.size())) {
                space.setNatSpace( networkSpaceList.get( natSpaceIndex ));
            } else {
                space.setNatSpace( null );
            }
        }

        /* Generate the interfaces, wire them up to the correct network space.
         * always wire settings up as if they were enabled. */
        List<Interface> intfList = new LinkedList<Interface>();
        for ( InterfaceInternal intfInternal : internalSettings.getEnabledList()) {
            Interface i = intfInternal.toInterface();
            NetworkSpace space = networkSpaceMap.get( intfInternal.getNetworkSpace());
            i.setNetworkSpace(( space == null ) ? primary : space );
            intfList.add( i );
        }

        /* Generate the routing table. */
        List<Route> routingTable = new LinkedList<Route>();
        for( RouteInternal r : internalSettings.getRoutingTable()) routingTable.add( r.toRoute());

        /* Set all of the simple settings (eg defaultRoute) */
        settings.setInterfaceList( intfList );
        settings.setNetworkSpaceList( networkSpaceList );
        settings.setRoutingTable( routingTable );
        settings.setDefaultRoute( internalSettings.getDefaultRoute());
        settings.setDns1( internalSettings.getDns1());
        settings.setDns2( internalSettings.getDns2());
        settings.setHasCompletedSetup( internalSettings.getHasCompletedSetup());

        settings.setRedirectList( internalSettings.getRedirectRuleList());

        return settings;
    }

    List<IPaddr> getDnsServers()
    {
        List<IPaddr> dnsServers = new LinkedList<IPaddr>();

        BufferedReader in = null;

        /* Open up the interfaces file */
        try {
            in = new BufferedReader( new FileReader( NetworkManagerImpl.ETC_RESOLV_FILE ));
            String str;
            while (( str = in.readLine()) != null ) {
                str = str.trim();
                if ( str.startsWith( ResolvScriptWriter.NS_PARAM )) {
                    String server = str.substring( ResolvScriptWriter.NS_PARAM.length()).trim();
                    
                    /* ignore anything that uses the localhost */
                    if ( "127.0.0.1".equals( server )) continue;
                    dnsServers.add( IPaddr.parse( server ));
                }
            }
        } catch ( Exception ex ) {
            logger.error( "Error reading file: ", ex );
        }

        try {
            if ( in != null ) in.close();
        } catch ( Exception ex ) {
            logger.error( "Unable to close file", ex );
        }

        return dnsServers;
    }

    /* Check if the address refers to the edgeguard box itself */
    public boolean isAddressLocal( NetworkSpacesInternalSettings settings, IPaddr address )
    {
        InetAddress addr = address.getAddr();
        if (addr.isLoopbackAddress() || addr.isLinkLocalAddress())
            return true;

        List<NetworkSpaceInternal> spaces = settings.getNetworkSpaceList();

        for (NetworkSpaceInternal space : spaces) {
            if (space.getIsEnabled()) {
                /* Check the primary address */
                if ( address.equals( space.getPrimaryAddress().getNetwork())) return true;

                for(IPNetwork aliasRule : (List<IPNetwork>) space.getNetworkList()) {
                    IPaddr alias = aliasRule.getNetwork();
                    if (alias.equals(address))
                        return true;
                }
            }

            /* Only check the first space if it is not enabled */
            if ( !settings.getIsEnabled()) break;
        }

        return false;
    }

    byte[] getArgonIntfArray()
    {
        return MvvmContextFactory.context().localIntfManager().getArgonIntfArray();
    }

    /* Get the hostname of the box from the /etc/hostname file */
    HostName loadHostname()
    {
        HostName hostname = NetworkUtil.DEFAULT_HOSTNAME;

        BufferedReader in = null;

        /* Open up the interfaces file */
        try {
            in = new BufferedReader(new FileReader( HOST_NAME_FILE ));
            String str;
            str = in.readLine().trim();

            /* Try to parse the hostname, throws an exception if it fails */
            hostname = HostName.parse( str );
        } catch ( Exception ex ) {
            /* Go to the default */
            hostname = NetworkUtil.DEFAULT_HOSTNAME;
        }

        try {
            if ( in != null ) in.close();
        } catch ( Exception e ) {
            logger.error( "Error closing file: " + e );
        }

        return hostname;
    }


    /************* PRIVATE **********/
    private IPNetwork getPrimaryAddress( NetworkSpace networkSpace, int index )
    {
        IPNetwork primaryAddress = IPNetwork.getEmptyNetwork();

        if ( networkSpace.getIsDhcpEnabled()) {
            DhcpStatus status = networkSpace.getDhcpStatus();
            primaryAddress = IPNetwork.makeInstance( status.getAddress(), status.getNetmask());
        } else {
            for ( IPNetworkRule rule : (List<IPNetworkRule>)networkSpace.getNetworkList()) {
                if ( rule.isUnicast()) {
                    primaryAddress = rule.getIPNetwork();
                    break;
                }
            }
        }

        if ( primaryAddress == null || primaryAddress.equals( IPNetwork.getEmptyNetwork())) {
            /* XXX This is where it would handle the empty ip network */
            logger.warn( "Network space " + index + " does not have a primary address" );
        }

        return ( primaryAddress == null ) ? IPNetwork.getEmptyNetwork() : primaryAddress;
    }

    private void setNatAddress( SpaceInfo info, Map<NetworkSpace,SpaceInfo> spaceToInfoMap )
        throws NetworkException
    {
        NetworkSpace space = info.getNetworkSpace();

        if ( !space.getIsNatEnabled()) return;

        NetworkSpace natSpace = space.getNatSpace();
        int natSpaceIndex = -1;
        IPaddr natAddress = NetworkUtil.EMPTY_IPADDR;

        if ( natSpace == space ) {
            throw new NetworkException( "Network space " + info.getIndex() + " is natted to itself" );
        }

        if ( natSpace == null ) {
            throw new NetworkException( "An enabled space [" + space.getName() +
                                        "] running nat must have a nat space" );
        }

        if ( space.isLive() && !natSpace.isLive()) {
            throw new NetworkException( "An enabled space cannot NAT to a disabled space." );
        }

        if ( spaceToInfoMap.get( natSpace ) == null ) {
            throw new NetworkException( "Network space " + info.getIndex() + " is not nattd to an " +
                                        "unlisted network space" );
        }

        /* Grab the info for the nat space */
        SpaceInfo i   = spaceToInfoMap.get( natSpace );

        /* By default use the primary address of the nat space */
        natAddress    = i.getPrimaryAddress().getNetwork();

        /* If the nat address is set, use the nat address */
        if ( space.getNatAddress() != null ) natAddress = space.getNatAddress();
        natSpaceIndex = i.getIndex();

        if ( natAddress == null || natAddress.isEmpty()) {
            logger.info( "Requesting NAT on a space that doesn't have an address, NATing to bogus address" );

            /* Very dirty */
            info.setNatAddress( NetworkUtil.BOGUS_DHCP_ADDRESS );
            info.setNatSpaceIndex( natSpaceIndex );
        } else {
            info.setNatAddress( natAddress );
            info.setNatSpaceIndex( natSpaceIndex );
        }
    }

    // Writes out the new ddclient config files when the ddns settings change.
    void writeDDNSConfiguration(DynamicDNSSettings settings, HostName hostName, String externalInterfaceName )
    {
        StringBuilder sb = new StringBuilder();
        boolean enabled = settings.isEnabled();

        sb.append(DDCLIENT_CONF_START);
        sb.append(externalInterfaceName);
        sb.append("\n");
        if (enabled) {
            // Don't write out any potentially sensitive information unless needed.
            sb.append("protocol=");
            sb.append(settings.getProtocol());
            sb.append("\n");
            sb.append("server=");
            sb.append(settings.getServer());
            sb.append("\n");
            sb.append("login=");
            sb.append(settings.getLogin());
            sb.append("\n");
            sb.append("password=");
            sb.append(settings.getPassword());
            sb.append("\n");
            sb.append(hostName);
            sb.append("\n");
        }
        ConfigFileUtil.writeFile( sb, DDCLIENT_CONF_FILE );
        ConfigFileUtil.protectFile(DDCLIENT_CONF_FILE);

        // Must stop before writing default file since /etc/init.d/ddclient script is stupid
        if (!enabled)
            stopDDNS();

        sb = new StringBuilder();
        sb.append(DDCLIENT_DEFAULT_START);
        sb.append("run_daemon=\"");
        if (enabled)
            sb.append("true");
        else
            sb.append("false");
        sb.append("\"\n");
        ConfigFileUtil.writeFile( sb, DDCLIENT_DEFAULT_FILE );
        ConfigFileUtil.protectFile(DDCLIENT_DEFAULT_FILE);

        if (enabled)
            restartDDNS();
    }

    private void restartDDNS() {
        int code;

        try {
            logger.debug( "Restarting ddclient server" );

            Process p = MvvmContextFactory.context().exec( DDCLIENT_CMD_RESTART );
            code = p.waitFor();
        } catch ( Exception e ) {
            logger.error( "Unable to restart ddclient server", e );
            return;
        }

        if ( code != 0 ) {
            logger.error( "Error restarting ddclient server" + code );
        }
    }

    private void stopDDNS() {
        int code;

        try {
            logger.debug( "Stopping ddclient server" );

            Process p = MvvmContextFactory.context().exec( DDCLIENT_CMD_STOP );
            code = p.waitFor();
        } catch ( Exception e ) {
            logger.error( "Unable to stop ddclient server", e );
            return;
        }

        if ( code != 0 ) {
            logger.error( "Error stopping ddclient server" + code );
        }
    }

    private NetworkSpaceInternal makeNetworkSpaceInternal( SpaceInfo info ) throws ValidateException
    {
        return NetworkSpaceInternal.
            makeInstance( info.getNetworkSpace(), info.getInterfaceList(), info.getPrimaryAddress(),
                          info.getDeviceName(), info.getIndex(), info.getNatAddress(),
                          info.getNatSpaceIndex());
    }

    static NetworkUtilPriv getPrivInstance()
    {
        return INSTANCE;
    }
}


class SpaceInfo
{
    private final NetworkSpace space;
    private final List<Interface> intfList;
    private final String deviceName;
    private final int index;
    private final IPNetwork primaryAddress;
    private IPaddr natAddress;
    private int natSpaceIndex;

    SpaceInfo( NetworkSpace space, String deviceName, int index, List<Interface> intfList,
               IPNetwork primaryAddress )
    {
        this.space = space;
        this.deviceName = deviceName;
        this.index = index;
        this.intfList = intfList;
        this.natAddress = NetworkUtil.EMPTY_IPADDR;
        this.primaryAddress = primaryAddress;
    }

    NetworkSpace getNetworkSpace()
    {
        return this.space;
    }

    List<Interface> getInterfaceList()
    {
        return this.intfList;
    }

    String getDeviceName()
    {
        return deviceName;
    }

    int getIndex()
    {
        return this.index;
    }

    IPNetwork getPrimaryAddress()
    {
        return this.primaryAddress;
    }

    IPaddr getNatAddress()
    {
        return this.natAddress;
    }

    void setNatAddress( IPaddr newValue )
    {
        this.natAddress = newValue;
    }

    int getNatSpaceIndex()
    {
        return this.natSpaceIndex;
    }

    void setNatSpaceIndex( int newValue )
    {
        this.natSpaceIndex = newValue;
    }
}
